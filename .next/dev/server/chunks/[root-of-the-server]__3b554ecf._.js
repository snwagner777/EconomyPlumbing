module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/child_process [external] (child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/assert [external] (assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/punycode [external] (punycode, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/querystring [external] (querystring, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/node:events [external] (node:events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:events", () => require("node:events"));

module.exports = mod;
}),
"[externals]/node:process [external] (node:process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:process", () => require("node:process"));

module.exports = mod;
}),
"[externals]/node:util [external] (node:util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:util", () => require("node:util"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[project]/server/objectStorage.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Reference: javascript_object_storage integration
__turbopack_context__.s([
    "ObjectNotFoundError",
    ()=>ObjectNotFoundError,
    "ObjectStorageService",
    ()=>ObjectStorageService,
    "objectStorageClient",
    ()=>objectStorageClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2d$cloud$2f$storage$2f$build$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@google-cloud/storage/build/esm/src/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2d$cloud$2f$storage$2f$build$2f$esm$2f$src$2f$storage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google-cloud/storage/build/esm/src/storage.js [app-route] (ecmascript)");
;
const REPLIT_SIDECAR_ENDPOINT = "http://127.0.0.1:1106";
const objectStorageClient = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2d$cloud$2f$storage$2f$build$2f$esm$2f$src$2f$storage$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Storage"]({
    credentials: {
        audience: "replit",
        subject_token_type: "access_token",
        token_url: `${REPLIT_SIDECAR_ENDPOINT}/token`,
        type: "external_account",
        credential_source: {
            url: `${REPLIT_SIDECAR_ENDPOINT}/credential`,
            format: {
                type: "json",
                subject_token_field_name: "access_token"
            }
        },
        universe_domain: "googleapis.com"
    },
    projectId: ""
});
class ObjectNotFoundError extends Error {
    constructor(){
        super("Object not found");
        this.name = "ObjectNotFoundError";
        Object.setPrototypeOf(this, ObjectNotFoundError.prototype);
    }
}
class ObjectStorageService {
    constructor(){}
    // Gets the public object search paths.
    getPublicObjectSearchPaths() {
        const pathsStr = process.env.PUBLIC_OBJECT_SEARCH_PATHS || "";
        const paths = Array.from(new Set(pathsStr.split(",").map((path)=>path.trim()).filter((path)=>path.length > 0)));
        if (paths.length === 0) {
            throw new Error("PUBLIC_OBJECT_SEARCH_PATHS not set. Create a bucket in 'Object Storage' " + "tool and set PUBLIC_OBJECT_SEARCH_PATHS env var (comma-separated paths).");
        }
        return paths;
    }
    // Search for a public object from the search paths.
    async searchPublicObject(filePath) {
        for (const searchPath of this.getPublicObjectSearchPaths()){
            const fullPath = `${searchPath}/${filePath}`;
            // Full path format: /<bucket_name>/<object_name>
            const { bucketName, objectName } = parseObjectPath(fullPath);
            const bucket = objectStorageClient.bucket(bucketName);
            const file = bucket.file(objectName);
            // Check if file exists
            const [exists] = await file.exists();
            if (exists) {
                return file;
            }
        }
        return null;
    }
    // Downloads an object to the response.
    async downloadObject(file, res, cacheTtlSec = 3600) {
        try {
            // Get file metadata
            const [metadata] = await file.getMetadata();
            // Set appropriate headers
            res.set({
                "Content-Type": metadata.contentType || "application/octet-stream",
                "Content-Length": metadata.size,
                "Cache-Control": `public, max-age=${cacheTtlSec}, immutable`
            });
            // Stream the file to the response
            const stream = file.createReadStream();
            stream.on("error", (err)=>{
                console.error("Stream error:", err);
                if (!res.headersSent) {
                    res.status(500).json({
                        error: "Error streaming file"
                    });
                }
            });
            stream.pipe(res);
        } catch (error) {
            console.error("Error downloading file:", error);
            if (!res.headersSent) {
                res.status(500).json({
                    error: "Error downloading file"
                });
            }
        }
    }
    // Upload a file to object storage
    async uploadFile(localFilePath, destinationPath, contentType) {
        const { bucketName, objectName } = parseObjectPath(destinationPath);
        const bucket = objectStorageClient.bucket(bucketName);
        const file = bucket.file(objectName);
        await bucket.upload(localFilePath, {
            destination: objectName,
            metadata: {
                contentType: contentType || "application/octet-stream",
                cacheControl: "public, max-age=31536000, immutable"
            }
        });
        // Return the public path for accessing the file
        return destinationPath;
    }
    // Upload a buffer directly to object storage (no temporary file needed)
    async uploadBuffer(buffer, destinationPath, contentType) {
        const { bucketName, objectName } = parseObjectPath(destinationPath);
        const bucket = objectStorageClient.bucket(bucketName);
        const file = bucket.file(objectName);
        await file.save(buffer, {
            metadata: {
                contentType: contentType || "application/octet-stream",
                cacheControl: "public, max-age=31536000, immutable"
            }
        });
        // Return the public path for accessing the file
        return destinationPath;
    }
    // Download a file from object storage as a buffer
    async downloadBuffer(filePath) {
        try {
            const { bucketName, objectName } = parseObjectPath(filePath);
            const bucket = objectStorageClient.bucket(bucketName);
            const file = bucket.file(objectName);
            // Check if file exists
            const [exists] = await file.exists();
            if (!exists) {
                return null;
            }
            // Download file as buffer
            const [buffer] = await file.download();
            return buffer;
        } catch (error) {
            console.error(`Error downloading buffer from ${filePath}:`, error);
            return null;
        }
    }
    // Delete a file from object storage
    async deleteFile(filePath) {
        const { bucketName, objectName } = parseObjectPath(filePath);
        const bucket = objectStorageClient.bucket(bucketName);
        const file = bucket.file(objectName);
        await file.delete();
    }
    // Alias for deleteFile for consistency
    async deleteObject(filePath) {
        await this.deleteFile(filePath);
    }
}
function parseObjectPath(path) {
    if (!path.startsWith("/")) {
        path = `/${path}`;
    }
    const pathParts = path.split("/");
    if (pathParts.length < 3) {
        throw new Error("Invalid path: must contain at least a bucket name");
    }
    const bucketName = pathParts[1];
    const objectName = pathParts.slice(2).join("/");
    return {
        bucketName,
        objectName
    };
}
}),
"[project]/app/public-objects/[...filePath]/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Public Object Storage API - Serve Public Files
 * 
 * Serves files from object storage with appropriate caching headers
 * Migrated from Express route: /public-objects/:filePath(*)
 */ __turbopack_context__.s([
    "GET",
    ()=>GET
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$server$2f$objectStorage$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/server/objectStorage.ts [app-route] (ecmascript)");
;
;
async function GET(req, { params }) {
    try {
        const { filePath } = await params;
        const filePathStr = filePath.join('/');
        const objectStorageService = new __TURBOPACK__imported__module__$5b$project$5d2f$server$2f$objectStorage$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectStorageService"]();
        // Search for the file in public object search paths
        const file = await objectStorageService.searchPublicObject(filePathStr);
        if (!file) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'File not found'
            }, {
                status: 404
            });
        }
        // Blog images get 1 year cache, others get 1 hour
        const cacheTtl = filePathStr.startsWith('blog_images/') ? 31536000 : 3600;
        // Get file metadata
        const [metadata] = await file.getMetadata();
        // Create a readable stream from the file
        const stream = file.createReadStream();
        // Convert Node.js stream to Web Stream for Next.js
        const readableStream = new ReadableStream({
            start (controller) {
                stream.on('data', (chunk)=>{
                    controller.enqueue(new Uint8Array(chunk));
                });
                stream.on('end', ()=>{
                    controller.close();
                });
                stream.on('error', (err)=>{
                    console.error('[Object Storage] Stream error:', err);
                    controller.error(err);
                });
            }
        });
        // Return streaming response with appropriate headers
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"](readableStream, {
            status: 200,
            headers: {
                'Content-Type': metadata.contentType || 'application/octet-stream',
                'Content-Length': String(metadata.size),
                'Cache-Control': `public, max-age=${cacheTtl}, immutable`
            }
        });
    } catch (error) {
        console.error('[Object Storage] Error serving file:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Internal server error'
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__3b554ecf._.js.map