{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 178, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/server/objectStorage.ts"],"sourcesContent":["// Reference: javascript_object_storage integration\nimport { Storage, File } from \"@google-cloud/storage\";\nimport { Response } from \"express\";\n\nconst REPLIT_SIDECAR_ENDPOINT = \"http://127.0.0.1:1106\";\n\n// The object storage client is used to interact with the object storage service.\nexport const objectStorageClient = new Storage({\n  credentials: {\n    audience: \"replit\",\n    subject_token_type: \"access_token\",\n    token_url: `${REPLIT_SIDECAR_ENDPOINT}/token`,\n    type: \"external_account\",\n    credential_source: {\n      url: `${REPLIT_SIDECAR_ENDPOINT}/credential`,\n      format: {\n        type: \"json\",\n        subject_token_field_name: \"access_token\",\n      },\n    },\n    universe_domain: \"googleapis.com\",\n  },\n  projectId: \"\",\n});\n\nexport class ObjectNotFoundError extends Error {\n  constructor() {\n    super(\"Object not found\");\n    this.name = \"ObjectNotFoundError\";\n    Object.setPrototypeOf(this, ObjectNotFoundError.prototype);\n  }\n}\n\n// The object storage service is used to interact with the object storage service.\nexport class ObjectStorageService {\n  constructor() {}\n\n  // Gets the public object search paths.\n  getPublicObjectSearchPaths(): Array<string> {\n    const pathsStr = process.env.PUBLIC_OBJECT_SEARCH_PATHS || \"\";\n    const paths = Array.from(\n      new Set(\n        pathsStr\n          .split(\",\")\n          .map((path) => path.trim())\n          .filter((path) => path.length > 0)\n      )\n    );\n    if (paths.length === 0) {\n      throw new Error(\n        \"PUBLIC_OBJECT_SEARCH_PATHS not set. Create a bucket in 'Object Storage' \" +\n          \"tool and set PUBLIC_OBJECT_SEARCH_PATHS env var (comma-separated paths).\"\n      );\n    }\n    return paths;\n  }\n\n  // Search for a public object from the search paths.\n  async searchPublicObject(filePath: string): Promise<File | null> {\n    for (const searchPath of this.getPublicObjectSearchPaths()) {\n      const fullPath = `${searchPath}/${filePath}`;\n\n      // Full path format: /<bucket_name>/<object_name>\n      const { bucketName, objectName } = parseObjectPath(fullPath);\n      const bucket = objectStorageClient.bucket(bucketName);\n      const file = bucket.file(objectName);\n\n      // Check if file exists\n      const [exists] = await file.exists();\n      if (exists) {\n        return file;\n      }\n    }\n\n    return null;\n  }\n\n  // Downloads an object to the response.\n  async downloadObject(file: File, res: Response, cacheTtlSec: number = 3600) {\n    try {\n      // Get file metadata\n      const [metadata] = await file.getMetadata();\n      \n      // Set appropriate headers\n      res.set({\n        \"Content-Type\": metadata.contentType || \"application/octet-stream\",\n        \"Content-Length\": metadata.size,\n        \"Cache-Control\": `public, max-age=${cacheTtlSec}, immutable`,\n      });\n\n      // Stream the file to the response\n      const stream = file.createReadStream();\n\n      stream.on(\"error\", (err) => {\n        console.error(\"Stream error:\", err);\n        if (!res.headersSent) {\n          res.status(500).json({ error: \"Error streaming file\" });\n        }\n      });\n\n      stream.pipe(res);\n    } catch (error) {\n      console.error(\"Error downloading file:\", error);\n      if (!res.headersSent) {\n        res.status(500).json({ error: \"Error downloading file\" });\n      }\n    }\n  }\n\n  // Upload a file to object storage\n  async uploadFile(\n    localFilePath: string,\n    destinationPath: string,\n    contentType?: string\n  ): Promise<string> {\n    const { bucketName, objectName } = parseObjectPath(destinationPath);\n    const bucket = objectStorageClient.bucket(bucketName);\n    const file = bucket.file(objectName);\n\n    await bucket.upload(localFilePath, {\n      destination: objectName,\n      metadata: {\n        contentType: contentType || \"application/octet-stream\",\n        cacheControl: \"public, max-age=31536000, immutable\", // 1 year cache for images\n      },\n    });\n\n    // Return the public path for accessing the file\n    return destinationPath;\n  }\n\n  // Upload a buffer directly to object storage (no temporary file needed)\n  async uploadBuffer(\n    buffer: Buffer,\n    destinationPath: string,\n    contentType?: string\n  ): Promise<string> {\n    const { bucketName, objectName } = parseObjectPath(destinationPath);\n    const bucket = objectStorageClient.bucket(bucketName);\n    const file = bucket.file(objectName);\n\n    await file.save(buffer, {\n      metadata: {\n        contentType: contentType || \"application/octet-stream\",\n        cacheControl: \"public, max-age=31536000, immutable\", // 1 year cache for images\n      },\n    });\n\n    // Return the public path for accessing the file\n    return destinationPath;\n  }\n\n  // Download a file from object storage as a buffer\n  async downloadBuffer(filePath: string): Promise<Buffer | null> {\n    try {\n      const { bucketName, objectName } = parseObjectPath(filePath);\n      const bucket = objectStorageClient.bucket(bucketName);\n      const file = bucket.file(objectName);\n\n      // Check if file exists\n      const [exists] = await file.exists();\n      if (!exists) {\n        return null;\n      }\n\n      // Download file as buffer\n      const [buffer] = await file.download();\n      return buffer;\n    } catch (error) {\n      console.error(`Error downloading buffer from ${filePath}:`, error);\n      return null;\n    }\n  }\n\n  // Delete a file from object storage\n  async deleteFile(filePath: string): Promise<void> {\n    const { bucketName, objectName } = parseObjectPath(filePath);\n    const bucket = objectStorageClient.bucket(bucketName);\n    const file = bucket.file(objectName);\n\n    await file.delete();\n  }\n  \n  // Alias for deleteFile for consistency\n  async deleteObject(filePath: string): Promise<void> {\n    await this.deleteFile(filePath);\n  }\n}\n\nfunction parseObjectPath(path: string): {\n  bucketName: string;\n  objectName: string;\n} {\n  if (!path.startsWith(\"/\")) {\n    path = `/${path}`;\n  }\n  const pathParts = path.split(\"/\");\n  if (pathParts.length < 3) {\n    throw new Error(\"Invalid path: must contain at least a bucket name\");\n  }\n\n  const bucketName = pathParts[1];\n  const objectName = pathParts.slice(2).join(\"/\");\n\n  return {\n    bucketName,\n    objectName,\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 352, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/public-objects/%5B...filePath%5D/route.ts"],"sourcesContent":["/**\n * Public Object Storage API - Serve Public Files\n * \n * Serves files from object storage with appropriate caching headers\n * Migrated from Express route: /public-objects/:filePath(*)\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { ObjectStorageService } from '@/server/objectStorage';\n\nexport async function GET(\n  req: NextRequest,\n  { params }: { params: Promise<{ filePath: string[] }> }\n) {\n  try {\n    const { filePath } = await params;\n    const filePathStr = filePath.join('/');\n    \n    const objectStorageService = new ObjectStorageService();\n    \n    // Search for the file in public object search paths\n    const file = await objectStorageService.searchPublicObject(filePathStr);\n    \n    if (!file) {\n      return NextResponse.json(\n        { error: 'File not found' },\n        { status: 404 }\n      );\n    }\n    \n    // Blog images get 1 year cache, others get 1 hour\n    const cacheTtl = filePathStr.startsWith('blog_images/') ? 31536000 : 3600;\n    \n    // Get file metadata\n    const [metadata] = await file.getMetadata();\n    \n    // Create a readable stream from the file\n    const stream = file.createReadStream();\n    \n    // Convert Node.js stream to Web Stream for Next.js\n    const readableStream = new ReadableStream({\n      start(controller) {\n        stream.on('data', (chunk: Buffer) => {\n          controller.enqueue(new Uint8Array(chunk));\n        });\n        \n        stream.on('end', () => {\n          controller.close();\n        });\n        \n        stream.on('error', (err) => {\n          console.error('[Object Storage] Stream error:', err);\n          controller.error(err);\n        });\n      },\n    });\n    \n    // Return streaming response with appropriate headers\n    return new NextResponse(readableStream, {\n      status: 200,\n      headers: {\n        'Content-Type': metadata.contentType || 'application/octet-stream',\n        'Content-Length': String(metadata.size),\n        'Cache-Control': `public, max-age=${cacheTtl}, immutable`,\n      },\n    });\n  } catch (error) {\n    console.error('[Object Storage] Error serving file:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAED;AACA;;;AAEO,eAAe,IACpB,GAAgB,EAChB,EAAE,MAAM,EAA+C;IAEvD,IAAI;QACF,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM;QAC3B,MAAM,cAAc,SAAS,IAAI,CAAC;QAElC,MAAM,uBAAuB,IAAI,iJAAoB;QAErD,oDAAoD;QACpD,MAAM,OAAO,MAAM,qBAAqB,kBAAkB,CAAC;QAE3D,IAAI,CAAC,MAAM;YACT,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAiB,GAC1B;gBAAE,QAAQ;YAAI;QAElB;QAEA,kDAAkD;QAClD,MAAM,WAAW,YAAY,UAAU,CAAC,kBAAkB,WAAW;QAErE,oBAAoB;QACpB,MAAM,CAAC,SAAS,GAAG,MAAM,KAAK,WAAW;QAEzC,yCAAyC;QACzC,MAAM,SAAS,KAAK,gBAAgB;QAEpC,mDAAmD;QACnD,MAAM,iBAAiB,IAAI,eAAe;YACxC,OAAM,UAAU;gBACd,OAAO,EAAE,CAAC,QAAQ,CAAC;oBACjB,WAAW,OAAO,CAAC,IAAI,WAAW;gBACpC;gBAEA,OAAO,EAAE,CAAC,OAAO;oBACf,WAAW,KAAK;gBAClB;gBAEA,OAAO,EAAE,CAAC,SAAS,CAAC;oBAClB,QAAQ,KAAK,CAAC,kCAAkC;oBAChD,WAAW,KAAK,CAAC;gBACnB;YACF;QACF;QAEA,qDAAqD;QACrD,OAAO,IAAI,gJAAY,CAAC,gBAAgB;YACtC,QAAQ;YACR,SAAS;gBACP,gBAAgB,SAAS,WAAW,IAAI;gBACxC,kBAAkB,OAAO,SAAS,IAAI;gBACtC,iBAAiB,CAAC,gBAAgB,EAAE,SAAS,WAAW,CAAC;YAC3D;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wCAAwC;QACtD,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}