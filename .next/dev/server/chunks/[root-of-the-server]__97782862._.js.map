{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/src/lib/session.ts"],"sourcesContent":["/**\n * Session Management for Next.js App Router\n * \n * Replaces express-session with iron-session for Next.js compatibility\n * Preserves all existing OAuth functionality\n */\n\nimport { getIronSession, type IronSession } from 'iron-session';\nimport { cookies } from 'next/headers';\n\nexport interface SessionData {\n  user?: {\n    id: string;\n    email: string;\n    firstName?: string;\n    lastName?: string;\n    profileImageUrl?: string;\n    claims?: any;\n    access_token?: string;\n    refresh_token?: string;\n    expires_at?: number;\n  };\n  isAdmin?: boolean;\n  oauthState?: string;\n  oauthCodeVerifier?: string;\n  customerPortalAuth?: {\n    customerId: number;\n    email: string;\n    phone: string;\n    verifiedAt: number;\n  };\n}\n\nif (!process.env.SESSION_SECRET) {\n  throw new Error('SESSION_SECRET environment variable is required');\n}\n\nconst sessionOptions = {\n  password: process.env.SESSION_SECRET,\n  cookieName: 'plumbing_session',\n  ttl: 7 * 24 * 60 * 60, // 1 week (in seconds)\n  cookieOptions: {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'lax' as const,\n    maxAge: 7 * 24 * 60 * 60, // 1 week (in seconds)\n    path: '/',\n  },\n};\n\n/**\n * Get the current session from cookies\n */\nexport async function getSession(): Promise<IronSession<SessionData>> {\n  const cookieStore = await cookies();\n  return getIronSession<SessionData>(cookieStore, sessionOptions);\n}\n\n/**\n * Check if user is authenticated\n */\nexport async function isAuthenticated(): Promise<boolean> {\n  const session = await getSession();\n  return !!session.user && !!session.user.expires_at && session.user.expires_at > Math.floor(Date.now() / 1000);\n}\n\n/**\n * Check if user is admin\n */\nexport async function isAdmin(): Promise<boolean> {\n  const session = await getSession();\n  return !!session.isAdmin && await isAuthenticated();\n}\n\n/**\n * Get current user from session\n */\nexport async function getCurrentUser() {\n  const session = await getSession();\n  return session.user;\n}\n\n/**\n * Destroy session (logout)\n */\nexport async function destroySession() {\n  const session = await getSession();\n  session.destroy();\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;;;;;;;AAED;AACA;;;AAyBA,IAAI,CAAC,QAAQ,GAAG,CAAC,cAAc,EAAE;IAC/B,MAAM,IAAI,MAAM;AAClB;AAEA,MAAM,iBAAiB;IACrB,UAAU,QAAQ,GAAG,CAAC,cAAc;IACpC,YAAY;IACZ,KAAK,IAAI,KAAK,KAAK;IACnB,eAAe;QACb,UAAU;QACV,QAAQ,oDAAyB;QACjC,UAAU;QACV,QAAQ,IAAI,KAAK,KAAK;QACtB,MAAM;IACR;AACF;AAKO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,OAAO,IAAA,oKAAc,EAAc,aAAa;AAClD;AAKO,eAAe;IACpB,MAAM,UAAU,MAAM;IACtB,OAAO,CAAC,CAAC,QAAQ,IAAI,IAAI,CAAC,CAAC,QAAQ,IAAI,CAAC,UAAU,IAAI,QAAQ,IAAI,CAAC,UAAU,GAAG,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;AAC1G;AAKO,eAAe;IACpB,MAAM,UAAU,MAAM;IACtB,OAAO,CAAC,CAAC,QAAQ,OAAO,IAAI,MAAM;AACpC;AAKO,eAAe;IACpB,MAAM,UAAU,MAAM;IACtB,OAAO,QAAQ,IAAI;AACrB;AAKO,eAAe;IACpB,MAAM,UAAU,MAAM;IACtB,QAAQ,OAAO;AACjB","debugId":null}},
    {"offset": {"line": 118, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/auth/login/route.ts"],"sourcesContent":["/**\n * OAuth Login Route\n * \n * Initiates Replit OAuth flow for admin authentication\n * with CSRF protection via session-stored state and PKCE\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport * as client from 'openid-client';\nimport { getSession } from '@/lib/session';\nimport { randomBytes } from 'crypto';\n\nexport async function GET(req: NextRequest) {\n  try {\n    const hostname = req.headers.get('host') || '';\n    \n    // Get OIDC configuration\n    const config = await client.discovery(\n      new URL(process.env.ISSUER_URL ?? 'https://replit.com/oidc'),\n      process.env.REPL_ID!\n    );\n\n    // Generate CSRF state and PKCE code verifier\n    const state = randomBytes(32).toString('hex');\n    const codeVerifier = client.randomPKCECodeVerifier();\n    const codeChallenge = await client.calculatePKCECodeChallenge(codeVerifier);\n\n    // Store state and code verifier in session for callback verification\n    const session = await getSession();\n    session.oauthState = state;\n    session.oauthCodeVerifier = codeVerifier;\n    await session.save();\n\n    // Generate authorization URL with PKCE\n    const authUrl = client.buildAuthorizationUrl(config, {\n      client_id: process.env.REPL_ID!,\n      redirect_uri: `https://${hostname}/api/auth/callback`,\n      scope: 'openid email profile offline_access',\n      prompt: 'login consent',\n      state,\n      code_challenge: codeChallenge,\n      code_challenge_method: 'S256',\n    });\n\n    // Redirect to Replit OAuth\n    return NextResponse.redirect(authUrl.href);\n  } catch (error) {\n    console.error('[OAuth] Error initiating login:', error);\n    return NextResponse.redirect('/admin-login?error=failed');\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAED;AACA;AACA;AACA;;;;;AAEO,eAAe,IAAI,GAAgB;IACxC,IAAI;QACF,MAAM,WAAW,IAAI,OAAO,CAAC,GAAG,CAAC,WAAW;QAE5C,yBAAyB;QACzB,MAAM,SAAS,MAAM,iLAAgB,CACnC,IAAI,IAAI,QAAQ,GAAG,CAAC,UAAU,IAAI,4BAClC,QAAQ,GAAG,CAAC,OAAO;QAGrB,6CAA6C;QAC7C,MAAM,QAAQ,IAAA,oHAAW,EAAC,IAAI,QAAQ,CAAC;QACvC,MAAM,eAAe,8LAA6B;QAClD,MAAM,gBAAgB,MAAM,kMAAiC,CAAC;QAE9D,qEAAqE;QACrE,MAAM,UAAU,MAAM,IAAA,qIAAU;QAChC,QAAQ,UAAU,GAAG;QACrB,QAAQ,iBAAiB,GAAG;QAC5B,MAAM,QAAQ,IAAI;QAElB,uCAAuC;QACvC,MAAM,UAAU,6LAA4B,CAAC,QAAQ;YACnD,WAAW,QAAQ,GAAG,CAAC,OAAO;YAC9B,cAAc,CAAC,QAAQ,EAAE,SAAS,kBAAkB,CAAC;YACrD,OAAO;YACP,QAAQ;YACR;YACA,gBAAgB;YAChB,uBAAuB;QACzB;QAEA,2BAA2B;QAC3B,OAAO,gJAAY,CAAC,QAAQ,CAAC,QAAQ,IAAI;IAC3C,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,mCAAmC;QACjD,OAAO,gJAAY,CAAC,QAAQ,CAAC;IAC/B;AACF","debugId":null}}]
}