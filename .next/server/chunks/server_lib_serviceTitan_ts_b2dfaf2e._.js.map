{"version":3,"sources":["turbopack:///[project]/server/lib/serviceTitan.ts"],"sourcesContent":["import type { InsertServiceTitanMembership, InsertServiceTitanCustomer, InsertServiceTitanContact } from \"@shared/schema\";\nimport { db } from \"../db\";\n\ninterface ServiceTitanConfig {\n  clientId: string;\n  clientSecret: string;\n  tenantId: string;\n  appKey: string;\n}\n\ninterface ServiceTitanContact {\n  id: number;\n  type: string;\n  value: string;\n  memo?: string;\n  phoneSettings?: {\n    phoneNumber: string;\n    doNotText: boolean;\n  };\n}\n\ninterface ServiceTitanCustomer {\n  id: number;\n  name?: string;\n  email?: string;\n  phoneNumber?: string;\n  contacts?: ServiceTitanContact[];\n  address?: {\n    street: string;\n    city: string;\n    state: string;\n    zip: string;\n  };\n}\n\ninterface ServiceTitanMembership {\n  id: number;\n  customerId: number;\n  membershipTypeId: number;\n  status: string;\n}\n\ninterface ServiceTitanInvoice {\n  id: number;\n  customerId: number;\n  total: number;\n  status: string;\n}\n\nclass ServiceTitanAPI {\n  private config: ServiceTitanConfig;\n  private baseUrl: string;\n  private accessToken: string | null = null;\n  private tokenExpiry: number = 0;\n\n  constructor(config: ServiceTitanConfig) {\n    this.config = config;\n    this.baseUrl = `https://api.servicetitan.io/crm/v2/tenant/${config.tenantId}`;\n  }\n\n  /**\n   * Authenticate with ServiceTitan OAuth 2.0\n   */\n  private async authenticate(): Promise<void> {\n    if (this.accessToken && Date.now() < this.tokenExpiry) {\n      return; // Token still valid\n    }\n\n    const tokenUrl = 'https://auth.servicetitan.io/connect/token';\n    const credentials = Buffer.from(`${this.config.clientId}:${this.config.clientSecret}`).toString('base64');\n\n    try {\n      const response = await fetch(tokenUrl, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Basic ${credentials}`,\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n        body: 'grant_type=client_credentials',\n      });\n\n      if (!response.ok) {\n        throw new Error(`Authentication failed: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      this.accessToken = data.access_token;\n      this.tokenExpiry = Date.now() + (data.expires_in * 1000) - 60000; // Refresh 1 min before expiry\n    } catch (error) {\n      console.error('[ServiceTitan] Authentication error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Make authenticated API request\n   * @param endpoint - Either a relative endpoint (e.g., \"/customers\") or a full URL\n   * @param options - Fetch options\n   * @param useFullUrl - If true, endpoint is treated as a full URL instead of appending to baseUrl\n   */\n  private async request<T>(endpoint: string, options: RequestInit = {}, useFullUrl: boolean = false): Promise<T> {\n    await this.authenticate();\n\n    const url = useFullUrl ? endpoint : `${this.baseUrl}${endpoint}`;\n    const headers = {\n      'Authorization': `Bearer ${this.accessToken}`,\n      'ST-App-Key': this.config.appKey,\n      'Content-Type': 'application/json',\n      ...options.headers,\n    };\n\n    console.log('[ServiceTitan] API Request:', {\n      url,\n      method: options.method || 'GET',\n      hasToken: !!this.accessToken,\n      hasAppKey: !!this.config.appKey\n    });\n\n    try {\n      const response = await fetch(url, { ...options, headers });\n\n      console.log('[ServiceTitan] API Response:', {\n        status: response.status,\n        statusText: response.statusText,\n        ok: response.ok\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('[ServiceTitan] API Error Response:', errorText);\n        throw new Error(`ServiceTitan API error: ${response.status} - ${errorText}`);\n      }\n\n      // Read the response body (ServiceTitan uses chunked encoding, so no content-length header)\n      const responseText = await response.text();\n      \n      // Handle empty responses\n      if (!responseText || responseText.trim() === '') {\n        console.log('[ServiceTitan] Empty response body');\n        return {} as T;\n      }\n\n      console.log('[ServiceTitan] Raw response text (first 1000 chars):', responseText.substring(0, 1000));\n      \n      try {\n        const jsonData = JSON.parse(responseText);\n        console.log('[ServiceTitan] Parsed JSON keys:', Object.keys(jsonData));\n        console.log('[ServiceTitan] Has data property:', 'data' in jsonData);\n        console.log('[ServiceTitan] Data length:', Array.isArray(jsonData?.data) ? jsonData.data.length : 'not an array');\n        \n        return jsonData;\n      } catch (parseError) {\n        console.error('[ServiceTitan] JSON parse error:', parseError);\n        console.error('[ServiceTitan] Response text was:', responseText);\n        throw new Error(`Failed to parse ServiceTitan response: ${parseError}`);\n      }\n    } catch (error) {\n      console.error('[ServiceTitan] API request error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Normalize phone number to digits only for comparison\n   */\n  private normalizePhone(phone: string): string {\n    // Remove all non-digits\n    const digits = phone.replace(/\\D/g, '');\n    // Remove leading 1 for US numbers\n    if (digits.length === 11 && digits.startsWith('1')) {\n      return digits.substring(1);\n    }\n    return digits;\n  }\n\n  /**\n   * Search for ALL customers by email or phone via live API (for multi-account support)\n   * Returns array of all matching customers, not just the first one\n   */\n  async searchAllCustomersLive(emailOrPhone: string): Promise<ServiceTitanCustomer[]> {\n    try {\n      const isEmail = emailOrPhone.includes('@');\n      console.log(`[ServiceTitan] Live API search for ALL customers with ${isEmail ? 'email' : 'phone'}: \"${emailOrPhone}\"`);\n      \n      if (isEmail) {\n        // Email search - returns all customers with this email\n        const emailResults = await this.request<{ data: ServiceTitanCustomer[] }>(\n          `/customers?email=${encodeURIComponent(emailOrPhone.trim())}`\n        );\n\n        if (emailResults.data && emailResults.data.length > 0) {\n          console.log(`[ServiceTitan] Found ${emailResults.data.length} customer(s) with email ${emailOrPhone}`);\n          return emailResults.data;\n        }\n      } else {\n        // Phone search - use contacts search API\n        const normalizedPhone = this.normalizePhone(emailOrPhone);\n        console.log(`[ServiceTitan] Searching for phone: ${normalizedPhone}`);\n        \n        try {\n          const contactsSearchUrl = `https://api.servicetitan.io/crm/v2/tenant/${this.config.tenantId}/contacts/search`;\n          const searchResults = await this.request<{ data: any[] }>(\n            contactsSearchUrl,\n            {\n              method: 'POST',\n              body: JSON.stringify({\n                value: normalizedPhone,\n                page: 1,\n                pageSize: 50 // Get up to 50 matching contacts\n              })\n            },\n            true\n          );\n\n          if (searchResults.data && searchResults.data.length > 0) {\n            // Get unique customer IDs\n            const customerIds = Array.from(new Set(searchResults.data.map((c: any) => c.customerId)));\n            console.log(`[ServiceTitan] Found ${customerIds.length} customer(s) with phone ${emailOrPhone}`);\n            \n            // Fetch full customer details for each ID\n            const customers: ServiceTitanCustomer[] = [];\n            for (const customerId of customerIds) {\n              try {\n                const customer = await this.request<ServiceTitanCustomer>(`/customers/${customerId}`);\n                customers.push(customer);\n              } catch (error) {\n                console.error(`[ServiceTitan] Failed to fetch customer ${customerId}:`, error);\n              }\n            }\n            return customers;\n          }\n        } catch (error: any) {\n          console.error('[ServiceTitan] Contacts search error:', error);\n        }\n      }\n      \n      console.log('[ServiceTitan] No customers found via live API');\n      return [];\n    } catch (error) {\n      console.error('[ServiceTitan] Live API search error:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Search for customer by email or phone (trying multiple approaches)\n   * Returns FIRST matching customer only\n   */\n  async searchCustomer(email: string, phone: string): Promise<ServiceTitanCustomer | null> {\n    try {\n      console.log(`[ServiceTitan] Searching for customer - email: \"${email}\", phone: \"${phone}\"`);\n      \n      let customerId: number | null = null;\n\n      // Strategy 1: Try email search first if provided (most reliable)\n      if (email && email.trim()) {\n        console.log('[ServiceTitan] Strategy 1: Searching by email...');\n        \n        try {\n          const emailResults = await this.request<{ data: ServiceTitanCustomer[] }>(\n            `/customers?email=${encodeURIComponent(email.trim())}`\n          );\n\n          if (emailResults.data && emailResults.data.length > 0) {\n            console.log(`[ServiceTitan] Found customer by email: ${emailResults.data[0].id}`);\n            return emailResults.data[0];\n          }\n          console.log('[ServiceTitan] No customer found by email');\n        } catch (error: any) {\n          console.error('[ServiceTitan] Email search error:', error.message);\n        }\n      }\n\n      // Strategy 2: Try Contacts Search API for phone (if available)\n      if (!customerId && phone && phone.trim()) {\n        console.log('[ServiceTitan] Strategy 2: Trying Contacts Search API for phone...');\n        \n        const normalizedPhone = this.normalizePhone(phone);\n        console.log(`[ServiceTitan] Normalized phone: \"${normalizedPhone}\"`);\n        \n        try {\n          const contactsSearchUrl = `https://api.servicetitan.io/crm/v2/tenant/${this.config.tenantId}/contacts/search`;\n          const searchResults = await this.request<{ data: any[] }>(\n            contactsSearchUrl,\n            {\n              method: 'POST',\n              body: JSON.stringify({\n                value: normalizedPhone,\n                page: 1,\n                pageSize: 10\n              })\n            },\n            true\n          );\n\n          if (searchResults.data && searchResults.data.length > 0) {\n            customerId = searchResults.data[0].customerId;\n            console.log(`[ServiceTitan] Contacts Search found customerId: ${customerId}`);\n          }\n        } catch (error: any) {\n          console.log('[ServiceTitan] Contacts Search API not available, trying alternative methods...');\n        }\n      }\n\n      // Strategy 3: Optimized pagination search (check first 250 customers in 5 pages)\n      if (!customerId && phone && phone.trim()) {\n        console.log('[ServiceTitan] Strategy 3: Fast pagination search (250 customers max)...');\n        \n        const normalizedPhone = this.normalizePhone(phone);\n        const MAX_PAGES = 5; // Only check 5 pages (250 customers) for speed\n        const PAGE_SIZE = 50;\n        const BATCH_SIZE = 10; // Check 10 customers at a time\n        \n        for (let page = 1; page <= MAX_PAGES; page++) {\n          console.log(`[ServiceTitan] Checking page ${page}/${MAX_PAGES}...`);\n          \n          const pageResults = await this.request<{ data: ServiceTitanCustomer[], hasMore?: boolean }>(\n            `/customers?page=${page}&pageSize=${PAGE_SIZE}`\n          );\n          \n          if (!pageResults.data || pageResults.data.length === 0) {\n            break;\n          }\n\n          // Check customers in batches\n          for (let i = 0; i < pageResults.data.length; i += BATCH_SIZE) {\n            const batch = pageResults.data.slice(i, i + BATCH_SIZE);\n            \n            const results = await Promise.allSettled(\n              batch.map(async (customer) => {\n                try {\n                  const contacts = await this.getCustomerContacts(customer.id);\n                  \n                  for (const contact of contacts) {\n                    const phoneValue = contact.value || contact.phoneSettings?.phoneNumber;\n                    if (phoneValue && (contact.type === 'Phone' || contact.type === 'MobilePhone')) {\n                      if (this.normalizePhone(phoneValue) === normalizedPhone) {\n                        console.log(`[ServiceTitan] MATCH FOUND! Customer ${customer.id} (${customer.name})`);\n                        return customer;\n                      }\n                    }\n                  }\n                  return null;\n                } catch (error) {\n                  return null;\n                }\n              })\n            );\n            \n            // Check for match\n            for (const result of results) {\n              if (result.status === 'fulfilled' && result.value) {\n                return result.value;\n              }\n            }\n          }\n          \n          // Stop if no more pages\n          if (pageResults.hasMore === false || pageResults.data.length < PAGE_SIZE) {\n            break;\n          }\n        }\n        \n        console.log(`[ServiceTitan] No match found in first ${MAX_PAGES * PAGE_SIZE} customers`);\n      }\n\n      // If we found a customer ID from Contacts Search, fetch full details\n      if (customerId) {\n        console.log(`[ServiceTitan] Fetching customer details for ID: ${customerId}`);\n        const customer = await this.request<ServiceTitanCustomer>(`/customers/${customerId}`);\n        return customer;\n      }\n\n      console.log('[ServiceTitan] Customer not found by any method');\n      return null;\n    } catch (error: any) {\n      console.error('[ServiceTitan] Search customer error:', error.message || error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create new customer (residential or commercial)\n   */\n  async createCustomer(data: {\n    type: 'residential' | 'commercial';\n    name?: string;\n    companyName?: string;\n    contactName?: string;\n    email: string;\n    phone: string;\n    street: string;\n    city: string;\n    state: string;\n    zip: string;\n  }): Promise<ServiceTitanCustomer> {\n    const address = {\n      street: data.street,\n      city: data.city,\n      state: data.state,\n      zip: data.zip,\n      country: 'USA',\n    };\n\n    // Create contacts array for customer\n    const customerContacts = [\n      { type: 'Phone', value: data.phone, isPrimary: true },\n      { type: 'Email', value: data.email, isPrimary: true }\n    ];\n\n    // Create location contacts array\n    const locationContacts = [\n      { type: 'Phone', value: data.phone, isPrimary: true },\n      { type: 'Email', value: data.email, isPrimary: true }\n    ];\n\n    // Build the request payload according to ServiceTitan API v2 format\n    const customerData = data.type === 'residential' \n      ? {\n          request: {\n            type: 'Residential',\n            name: data.name,\n            contacts: customerContacts,\n            locations: [{\n              name: 'Primary Residence',\n              address: address,\n              contacts: locationContacts\n            }]\n          }\n        }\n      : {\n          request: {\n            type: 'Commercial',\n            companyName: data.companyName,\n            contacts: customerContacts,\n            locations: [{\n              name: data.companyName || 'Primary Location',\n              address: address,\n              contacts: locationContacts\n            }]\n          }\n        };\n\n    try {\n      const result = await this.request<{ data: ServiceTitanCustomer }>(\n        '/customers',\n        {\n          method: 'POST',\n          body: JSON.stringify(customerData),\n        }\n      );\n\n      return result.data;\n    } catch (error) {\n      console.error('[ServiceTitan] Create customer error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create invoice with membership pricebook item\n   * This creates the membership and activates it for the customer\n   */\n  async createMembershipInvoice(\n    customerId: number, \n    membershipTypeId: number,\n    amount: number\n  ): Promise<ServiceTitanInvoice> {\n    try {\n      const invoiceData = {\n        customerId,\n        items: [{\n          skuId: membershipTypeId, // The membership pricebook item\n          quantity: 1,\n          price: amount,\n        }],\n        // Add other required invoice fields\n      };\n\n      const result = await this.request<{ data: ServiceTitanInvoice }>(\n        '/accounting/v2/invoices',\n        {\n          method: 'POST',\n          body: JSON.stringify(invoiceData),\n        }\n      );\n\n      return result.data;\n    } catch (error) {\n      console.error('[ServiceTitan] Create membership invoice error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Mark invoice as paid\n   */\n  async markInvoicePaid(invoiceId: number, amount: number, paymentMethod: string = 'Credit Card'): Promise<void> {\n    try {\n      await this.request(\n        `/invoices/${invoiceId}/payments`,\n        {\n          method: 'POST',\n          body: JSON.stringify({\n            amount,\n            paymentMethod,\n            status: 'Paid',\n          }),\n        }\n      );\n    } catch (error) {\n      console.error('[ServiceTitan] Mark invoice paid error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Complete membership purchase workflow\n   * 1. Search for customer\n   * 2. Create customer if not found\n   * 3. Create invoice with membership item (activates membership)\n   * 4. Mark invoice as paid\n   */\n  async processMembershipPurchase(\n    purchaseData: InsertServiceTitanMembership\n  ): Promise<{\n    customerId: number;\n    membershipId: number;\n    invoiceId: number;\n  }> {\n    try {\n      // Validate membershipTypeId\n      if (!purchaseData.serviceTitanMembershipTypeId) {\n        throw new Error('ServiceTitan membership type ID is required but missing. Please configure the product with a valid ServiceTitan membership type ID.');\n      }\n      \n      const membershipTypeId = parseInt(purchaseData.serviceTitanMembershipTypeId);\n      if (isNaN(membershipTypeId)) {\n        throw new Error(`Invalid ServiceTitan membership type ID: \"${purchaseData.serviceTitanMembershipTypeId}\". Must be a numeric ID.`);\n      }\n      \n      // Step 1: Search for existing customer\n      let customer = await this.searchCustomer(purchaseData.email, purchaseData.phone);\n\n      // Step 2: Create customer if not found\n      if (!customer) {\n        console.log('[ServiceTitan] Customer not found, creating new customer...');\n        customer = await this.createCustomer({\n          type: purchaseData.customerType as 'residential' | 'commercial',\n          name: purchaseData.customerName || undefined,\n          companyName: purchaseData.companyName || undefined,\n          contactName: purchaseData.contactPersonName || undefined,\n          email: purchaseData.email,\n          phone: purchaseData.phone,\n          street: purchaseData.street,\n          city: purchaseData.city,\n          state: purchaseData.state,\n          zip: purchaseData.zip,\n        });\n        console.log(`[ServiceTitan] Created customer with ID: ${customer.id}`);\n      } else {\n        console.log(`[ServiceTitan] Found existing customer with ID: ${customer.id}`);\n      }\n\n      // Step 3: Create invoice with membership pricebook item\n      // This creates AND activates the membership\n      console.log('[ServiceTitan] Creating membership invoice...');\n      const invoice = await this.createMembershipInvoice(\n        customer.id, \n        membershipTypeId,\n        purchaseData.amount / 100 // Convert cents to dollars\n      );\n      console.log(`[ServiceTitan] Created invoice with ID: ${invoice.id}`);\n\n      // Step 4: Mark invoice as paid\n      console.log('[ServiceTitan] Marking invoice as paid...');\n      await this.markInvoicePaid(invoice.id, purchaseData.amount / 100); // Convert cents to dollars\n      console.log('[ServiceTitan] Invoice marked as paid');\n\n      return {\n        customerId: customer.id,\n        membershipId: invoice.id, // The invoice ID serves as membership reference\n        invoiceId: invoice.id,\n      };\n    } catch (error) {\n      console.error('[ServiceTitan] Process membership purchase error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get customer contacts (phone/email)\n   */\n  async getCustomerContacts(customerId: number): Promise<any[]> {\n    try {\n      const result = await this.request<{ data: any[] }>(\n        `/customers/${customerId}/contacts`\n      );\n      return result.data || [];\n    } catch (error) {\n      console.error('[ServiceTitan] Get customer contacts error:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get customer by ID\n   */\n  async getCustomer(customerId: number): Promise<ServiceTitanCustomer> {\n    try {\n      // Customer endpoint returns object directly, not wrapped in {data: ...}\n      const customerData: any = await this.request<any>(\n        `/customers/${customerId}`\n      );\n      \n      // Fetch customer contacts to get phone/email\n      const contacts = await this.getCustomerContacts(customerId);\n      \n      // ServiceTitan returns contacts with type 'Email', 'Phone', 'MobilePhone', etc.\n      // Each contact has a 'value' field with the actual data\n      const emailContact = contacts.find((c: any) => c.type === 'Email');\n      const phoneContact = contacts.find((c: any) => c.type === 'Phone' || c.type === 'MobilePhone') || contacts.find((c: any) => c.phoneSettings);\n      \n      console.log(`[Portal Debug] Customer ${customerId} - Found ${contacts.length} contacts`);\n      console.log(`[Portal Debug] Email contact:`, emailContact?.value || 'NONE');\n      console.log(`[Portal Debug] Phone contact:`, phoneContact?.value || phoneContact?.phoneSettings?.phoneNumber || 'NONE');\n      console.log(`[Portal Debug] Customer record email:`, customerData.email || 'NONE');\n      console.log(`[Portal Debug] Customer record phoneNumber:`, customerData.phoneNumber || 'NONE');\n      \n      // Use contacts first, fall back to customer record fields if contacts are empty\n      const result = {\n        ...customerData,\n        email: emailContact?.value || customerData.email || '',\n        phoneNumber: phoneContact?.value || phoneContact?.phoneSettings?.phoneNumber || customerData.phoneNumber || '',\n        contacts: contacts.map((c: any) => ({\n          id: c.id,\n          type: c.type,\n          value: c.value || c.phoneSettings?.phoneNumber || '',\n          memo: c.memo,\n          phoneSettings: c.phoneSettings\n        }))\n      };\n      \n      console.log(`[Portal Debug] Final email field:`, result.email || 'EMPTY STRING');\n      console.log(`[Portal Debug] Final phoneNumber field:`, result.phoneNumber || 'EMPTY STRING');\n      console.log(`[Portal Debug] Returning ${result.contacts.length} contacts`);\n      \n      return result;\n    } catch (error) {\n      console.error('[ServiceTitan] Get customer error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update customer contact information\n   */\n  async updateCustomerContacts(\n    customerId: number,\n    data: {\n      email?: string;\n      phone?: string;\n    }\n  ): Promise<void> {\n    try {\n      console.log(`[ServiceTitan] Updating customer ${customerId} contacts...`);\n      \n      // Get existing contacts\n      const existingContacts = await this.getCustomerContacts(customerId);\n      \n      // Update or add email contact\n      if (data.email) {\n        const emailContact = existingContacts.find((c: any) => c.type === 'Email');\n        if (emailContact) {\n          // Update existing email\n          await this.request(\n            `/customers/${customerId}/contacts/${emailContact.id}`,\n            {\n              method: 'PUT',\n              body: JSON.stringify({\n                type: 'Email',\n                value: data.email,\n                memo: 'email'\n              }),\n            }\n          );\n        } else {\n          // Create new email contact\n          await this.request(\n            `/customers/${customerId}/contacts`,\n            {\n              method: 'POST',\n              body: JSON.stringify({\n                type: 'Email',\n                value: data.email,\n                memo: 'email'\n              }),\n            }\n          );\n        }\n      }\n      \n      // Update or add phone contact\n      if (data.phone) {\n        const phoneContact = existingContacts.find((c: any) => c.type === 'Phone' || c.type === 'MobilePhone');\n        if (phoneContact) {\n          // Update existing phone\n          await this.request(\n            `/customers/${customerId}/contacts/${phoneContact.id}`,\n            {\n              method: 'PUT',\n              body: JSON.stringify({\n                type: phoneContact.type,\n                value: data.phone,\n                memo: phoneContact.memo || 'Phone',\n                phoneSettings: {\n                  phoneNumber: data.phone,\n                  doNotText: phoneContact.phoneSettings?.doNotText || false\n                }\n              }),\n            }\n          );\n        } else {\n          // Create new phone contact\n          await this.request(\n            `/customers/${customerId}/contacts`,\n            {\n              method: 'POST',\n              body: JSON.stringify({\n                type: 'Phone',\n                value: data.phone,\n                memo: 'Phone',\n                phoneSettings: {\n                  phoneNumber: data.phone,\n                  doNotText: false\n                }\n              }),\n            }\n          );\n        }\n      }\n      \n      console.log('[ServiceTitan] Customer contacts updated successfully');\n    } catch (error) {\n      console.error('[ServiceTitan] Update customer contacts error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a customer contact by ID\n   */\n  async deleteCustomerContact(customerId: number, contactId: number): Promise<void> {\n    try {\n      console.log(`[ServiceTitan] Deleting contact ${contactId} for customer ${customerId}...`);\n      \n      await this.request(\n        `/customers/${customerId}/contacts/${contactId}`,\n        {\n          method: 'DELETE',\n        }\n      );\n      \n      console.log('[ServiceTitan] Contact deleted successfully');\n    } catch (error) {\n      console.error('[ServiceTitan] Delete contact error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update location address\n   */\n  async updateLocation(\n    locationId: number,\n    data: {\n      street: string;\n      city: string;\n      state: string;\n      zip: string;\n    }\n  ): Promise<void> {\n    try {\n      console.log(`[ServiceTitan] Updating location ${locationId}...`);\n      \n      const address = {\n        street: data.street,\n        city: data.city,\n        state: data.state,\n        zip: data.zip,\n        country: 'USA',\n      };\n      \n      await this.request(\n        `/locations/${locationId}`,\n        {\n          method: 'PUT',\n          body: JSON.stringify({\n            address: address\n          }),\n        }\n      );\n      \n      console.log('[ServiceTitan] Location updated successfully');\n    } catch (error) {\n      console.error('[ServiceTitan] Update location error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get customer's primary location\n   */\n  async getCustomerPrimaryLocation(customerId: number): Promise<any> {\n    try {\n      const locationsUrl = `https://api.servicetitan.io/crm/v2/tenant/${this.config.tenantId}/locations?customerId=${customerId}`;\n      const result = await this.request<{ data: any[] }>(locationsUrl, {}, true);\n      \n      // Return first location (primary)\n      return result.data && result.data.length > 0 ? result.data[0] : null;\n    } catch (error) {\n      console.error('[ServiceTitan] Get customer primary location error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get ALL locations for a customer (not just primary)\n   */\n  async getAllCustomerLocations(customerId: number): Promise<any[]> {\n    try {\n      const locationsUrl = `https://api.servicetitan.io/crm/v2/tenant/${this.config.tenantId}/locations?customerId=${customerId}`;\n      const result = await this.request<{ data: any[] }>(locationsUrl, {}, true);\n      \n      console.log(`[ServiceTitan] Found ${result.data?.length || 0} locations for customer ${customerId}`);\n      \n      // Return all locations\n      return result.data || [];\n    } catch (error) {\n      console.error('[ServiceTitan] Get all customer locations error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get available arrival windows from ServiceTitan\n   * This fetches recent appointments and extracts unique arrival windows\n   */\n  async getArrivalWindows(): Promise<Array<{ start: string; end: string; label: string }>> {\n    try {\n      // Fetch recent appointments to see what windows are being used\n      const jpmUrl = `https://api.servicetitan.io/jpm/v2/tenant/${this.config.tenantId}/appointments?pageSize=100`;\n      const result = await this.request<{ data: any[] }>(jpmUrl, {}, true);\n      \n      const appointments = result.data || [];\n      \n      // Extract unique arrival windows\n      const windowsMap = new Map<string, { start: string; end: string }>();\n      \n      appointments.forEach((apt: any) => {\n        if (apt.arrivalWindowStart && apt.arrivalWindowEnd) {\n          const startTime = new Date(apt.arrivalWindowStart);\n          const endTime = new Date(apt.arrivalWindowEnd);\n          \n          // Format as HH:MM\n          const startStr = `${startTime.getUTCHours().toString().padStart(2, '0')}:${startTime.getUTCMinutes().toString().padStart(2, '0')}`;\n          const endStr = `${endTime.getUTCHours().toString().padStart(2, '0')}:${endTime.getUTCMinutes().toString().padStart(2, '0')}`;\n          \n          const key = `${startStr}-${endStr}`;\n          if (!windowsMap.has(key)) {\n            windowsMap.set(key, { start: startStr, end: endStr });\n          }\n        }\n      });\n      \n      // Convert to array and sort by start time\n      const windows = Array.from(windowsMap.values()).sort((a, b) => {\n        return a.start.localeCompare(b.start);\n      });\n      \n      // Format with labels\n      return windows.map(w => {\n        const formatTime = (timeStr: string) => {\n          const [hours, minutes] = timeStr.split(':').map(Number);\n          const period = hours >= 12 ? 'PM' : 'AM';\n          const displayHours = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;\n          return `${displayHours}:${minutes.toString().padStart(2, '0')} ${period}`;\n        };\n        \n        return {\n          start: w.start,\n          end: w.end,\n          label: `${formatTime(w.start)} - ${formatTime(w.end)}`\n        };\n      });\n    } catch (error) {\n      console.error('[ServiceTitan] Get arrival windows error:', error);\n      // Return default windows if API fails\n      return [\n        { start: \"08:00\", end: \"12:00\", label: \"8:00 AM - 12:00 PM\" },\n        { start: \"12:00\", end: \"16:00\", label: \"12:00 PM - 4:00 PM\" },\n        { start: \"16:00\", end: \"20:00\", label: \"4:00 PM - 8:00 PM\" }\n      ];\n    }\n  }\n\n  /**\n   * Reschedule an appointment\n   */\n  async rescheduleAppointment(appointmentId: number, newStart: string, newEnd: string): Promise<any> {\n    try {\n      const jpmUrl = `https://api.servicetitan.io/jpm/v2/tenant/${this.config.tenantId}/appointments/${appointmentId}`;\n      \n      const payload = {\n        start: newStart,\n        end: newEnd,\n        arrivalWindowStart: newStart,\n        arrivalWindowEnd: newEnd,\n      };\n\n      console.log(`[ServiceTitan] Rescheduling appointment ${appointmentId} to ${newStart}`);\n      \n      const result = await this.request<{ data: any }>(jpmUrl, {\n        method: 'PUT',\n        body: JSON.stringify(payload),\n      }, true);\n\n      console.log('[ServiceTitan] Appointment rescheduled successfully');\n      return result.data;\n    } catch (error) {\n      console.error('[ServiceTitan] Reschedule appointment error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get customer appointments (actual scheduled visits)\n   */\n  async getCustomerAppointments(customerId: number): Promise<any[]> {\n    try {\n      // First, get all jobs for this customer\n      const jpmUrl = `https://api.servicetitan.io/jpm/v2/tenant/${this.config.tenantId}/jobs?customerId=${customerId}&pageSize=50`;\n      const jobsResult = await this.request<{ data: any[] }>(jpmUrl, {}, true);\n      \n      const jobs = jobsResult.data || [];\n      \n      // Then fetch appointments for each job\n      const appointmentPromises = jobs.map(async (job: any) => {\n        try {\n          if (!job.firstAppointmentId && !job.lastAppointmentId) {\n            return [];\n          }\n          \n          // Try to fetch appointments from the appointments API\n          const appointmentsUrl = `https://api.servicetitan.io/jpm/v2/tenant/${this.config.tenantId}/appointments?jobId=${job.id}&pageSize=50`;\n          const appointmentsResult = await this.request<{ data: any[] }>(appointmentsUrl, {}, true);\n          \n          return (appointmentsResult.data || []).map((apt: any) => ({\n            id: apt.id,\n            start: apt.start || apt.scheduledOn || apt.arrivalWindowStart,\n            end: apt.end || apt.arrivalWindowEnd,\n            status: apt.appointmentStatus || apt.status || 'Scheduled',\n            arrivalWindowStart: apt.arrivalWindowStart,\n            arrivalWindowEnd: apt.arrivalWindowEnd,\n            jobType: job.jobType || 'Service Call',\n            jobNumber: job.jobNumber,\n            summary: job.summary || apt.summary || `Appointment for Job #${job.jobNumber}`,\n          }));\n        } catch (error) {\n          // If appointments API fails, fall back to job data\n          console.log(`[ServiceTitan] Could not fetch appointments for job ${job.id}, using job data`);\n          return [{\n            id: job.id,\n            start: job.createdOn,\n            end: job.completedOn,\n            status: job.jobStatus || 'Unknown',\n            arrivalWindowStart: null,\n            arrivalWindowEnd: null,\n            jobType: 'Service Call',\n            jobNumber: job.jobNumber,\n            summary: job.summary || `Job #${job.jobNumber}`,\n          }];\n        }\n      });\n      \n      const allAppointments = await Promise.all(appointmentPromises);\n      return allAppointments.flat();\n    } catch (error) {\n      console.error('[ServiceTitan] Get customer appointments error:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get customer invoices\n   */\n  async getCustomerInvoices(customerId: number): Promise<any[]> {\n    try {\n      // Use accounting API for invoices\n      const accountingUrl = `https://api.servicetitan.io/accounting/v2/tenant/${this.config.tenantId}/invoices?customerId=${customerId}&pageSize=50`;\n      const result = await this.request<{ data: any[] }>(accountingUrl, {}, true);\n      \n      console.log('[ServiceTitan] Invoices response structure:', JSON.stringify(result, null, 2).substring(0, 500));\n      \n      // Map invoices to display format based on actual ServiceTitan response\n      const invoices = result.data || [];\n      return invoices.map((invoice: any) => ({\n        id: invoice.id,\n        invoiceNumber: invoice.referenceNumber || invoice.id?.toString(),\n        total: parseFloat(invoice.total || '0'),\n        balance: parseFloat(invoice.balance || '0'),\n        status: invoice.balance === '0.00' || invoice.balance === 0 ? 'Paid' : 'Outstanding',\n        createdOn: invoice.invoiceDate || invoice.createdOn,\n        dueDate: invoice.dueDate || null,\n        jobNumber: invoice.referenceNumber || null,\n        summary: invoice.summary || `Invoice #${invoice.referenceNumber || invoice.id}`,\n      }));\n    } catch (error) {\n      console.error('[ServiceTitan] Get customer invoices error:', error);\n      // Return empty array on error rather than throwing\n      return [];\n    }\n  }\n\n  /**\n   * Get customer memberships (VIP status, active memberships)\n   */\n  async getCustomerMemberships(customerId: number): Promise<any[]> {\n    try {\n      // ServiceTitan memberships API endpoint \n      // Using the correct /memberships endpoint with customerIds parameter\n      const membershipsUrl = `https://api.servicetitan.io/memberships/v2/tenant/${this.config.tenantId}/memberships?customerIds=${customerId}&active=Any&pageSize=50`;\n      const result = await this.request<{ data: any[] }>(membershipsUrl, {}, true);\n      \n      console.log('[ServiceTitan] Memberships API response:', {\n        totalCount: result.data?.length || 0,\n        memberships: result.data?.map((m: any) => ({\n          id: m.id,\n          status: m.status,\n          name: m.name,\n          duration: m.duration,\n          billingFrequency: m.billingFrequency,\n          createdOn: m.createdOn,\n          modifiedOn: m.modifiedOn,\n          active: m.active\n        })) || []\n      });\n      \n      // Map memberships to display format\n      const memberships = result.data || [];\n      \n      // Filter OUT deleted memberships (but keep expired/suspended ones to show history)\n      const displayableMemberships = memberships.filter((m: any) => {\n        // Skip if missing required fields\n        if (!m.name && !m.id) return false;\n        \n        // Skip deleted memberships\n        const status = (m.status || '').toLowerCase();\n        if (status === 'deleted') return false;\n        \n        return true;\n      });\n      \n      console.log('[ServiceTitan] Filtered memberships (excluding canceled):', {\n        inputCount: memberships.length,\n        displayableCount: displayableMemberships.length,\n        memberships: displayableMemberships.map((m: any) => ({\n          name: m.membershipName,\n          status: m.status,\n          expiresOn: m.to || m.expirationDate,\n          canceledOn: m.canceledOn\n        }))\n      });\n      \n      // Group by membership to avoid duplicates\n      const uniqueMemberships = new Map();\n      displayableMemberships.forEach((membership: any) => {\n        const key = membership.id;\n        \n        // Map membership status - using the actual API status values\n        // Values from API docs: Active, Suspended, Expired, Canceled, Deleted\n        const status = membership.status || 'Unknown';\n        const isActive = status === 'Active';\n        const isExpired = status === 'Expired';\n        \n        // Use duration to determine if it has an expiration\n        // duration = null means ongoing/no expiration\n        const hasExpiration = membership.duration !== null && membership.duration !== undefined;\n        \n        uniqueMemberships.set(key, {\n          id: membership.id,\n          membershipType: membership.name || 'VIP Membership',\n          status: status,\n          isExpired: isExpired || status === 'Canceled',\n          startDate: membership.createdOn,\n          expirationDate: hasExpiration ? membership.expirationDate : null,\n          renewalDate: membership.renewalDate,\n          balance: 0, // These fields may not exist in the new API\n          totalValue: 0,\n          description: membership.description || '',\n          rawStatus: membership.status,\n          billingFrequency: membership.billingFrequency,\n          duration: membership.duration,\n          active: membership.active\n        });\n      });\n      \n      return Array.from(uniqueMemberships.values());\n    } catch (error) {\n      console.error('[ServiceTitan] Get customer memberships error:', error);\n      // Return empty array on error rather than throwing\n      return [];\n    }\n  }\n\n  /**\n   * Get customer estimates (open quotes/proposals) with full pricebook item details\n   */\n  async getCustomerEstimates(customerId: number): Promise<any[]> {\n    try {\n      // ServiceTitan Sales & Estimates API endpoint\n      const salesUrl = `https://api.servicetitan.io/sales/v2/tenant/${this.config.tenantId}/estimates?customerId=${customerId}&pageSize=50`;\n      const result = await this.request<{ data: any[] }>(salesUrl, {}, true);\n      \n      console.log('[ServiceTitan] Estimates API response received:', {\n        totalCount: result.data?.length || 0,\n        statuses: result.data?.map((e: any) => ({ id: e.id, status: e.status, soldOn: e.soldOn })) || []\n      });\n      \n      // Map estimates to display format\n      const estimates = result.data || [];\n      \n      // Filter for UNSOLD estimates only (where soldOn is null/empty)\n      const unsoldEstimates = estimates.filter((e: any) => !e.soldOn);\n      console.log(`[ServiceTitan] Filtered to ${unsoldEstimates.length} unsold estimates from ${estimates.length} total`);\n      \n      // Create memoization cache for pricebook items to avoid duplicate API calls\n      const pricebookCache = new Map<string, any>();\n      \n      // Enhance each estimate with pricebook item details\n      const enhancedEstimates = await Promise.all(\n        unsoldEstimates.map(async (estimate: any) => {\n          const items = estimate.items || [];\n          \n          // Fetch pricebook details for each item\n          const enhancedItems = await Promise.all(\n            items.map(async (item: any) => {\n              let pricebookDetails = null;\n              \n              try {\n                // Determine item type and fetch details (with memoization)\n                // ServiceTitan estimates typically have serviceId, materialId, or equipmentId\n                let cacheKey = '';\n                \n                if (item.serviceId || item.skuId) {\n                  const id = item.serviceId || item.skuId;\n                  cacheKey = `service-${id}`;\n                  \n                  if (!pricebookCache.has(cacheKey)) {\n                    const details = await this.getPricebookService(id);\n                    pricebookCache.set(cacheKey, details);\n                  }\n                  pricebookDetails = pricebookCache.get(cacheKey);\n                  \n                } else if (item.materialId) {\n                  cacheKey = `material-${item.materialId}`;\n                  \n                  if (!pricebookCache.has(cacheKey)) {\n                    const details = await this.getPricebookMaterial(item.materialId);\n                    pricebookCache.set(cacheKey, details);\n                  }\n                  pricebookDetails = pricebookCache.get(cacheKey);\n                  \n                } else if (item.equipmentId) {\n                  cacheKey = `equipment-${item.equipmentId}`;\n                  \n                  if (!pricebookCache.has(cacheKey)) {\n                    const details = await this.getPricebookEquipment(item.equipmentId);\n                    pricebookCache.set(cacheKey, details);\n                  }\n                  pricebookDetails = pricebookCache.get(cacheKey);\n                }\n              } catch (error) {\n                // Log but don't fail - missing pricebook details shouldn't break the estimate\n                console.error('[ServiceTitan] Error fetching pricebook details for item:', item, error);\n                pricebookDetails = null;\n              }\n              \n              return {\n                ...item,\n                quantity: item.qty || 1,\n                unitRate: item.unitRate || 0,\n                total: item.total || 0,\n                description: item.description || '',\n                pricebookDetails, // Add full pricebook data (name, description, imageUrl, etc.) or null if failed\n              };\n            })\n          );\n          \n          // Calculate expiration status\n          const createdDate = new Date(estimate.createdOn || estimate.createdDate);\n          const expiresDate = estimate.expiresOn || estimate.expirationDate \n            ? new Date(estimate.expiresOn || estimate.expirationDate)\n            : new Date(createdDate.getTime() + (30 * 24 * 60 * 60 * 1000)); // 30 days from creation\n          \n          const now = new Date();\n          const daysUntilExpiration = Math.ceil((expiresDate.getTime() - now.getTime()) / (24 * 60 * 60 * 1000));\n          \n          let expirationStatus = 'valid';\n          if (daysUntilExpiration < 0) {\n            expirationStatus = 'expired';\n          } else if (daysUntilExpiration <= 7) {\n            expirationStatus = 'expiring_soon';\n          }\n          \n          return {\n            id: estimate.id,\n            estimateNumber: estimate.number || estimate.estimateNumber || estimate.id?.toString(),\n            total: parseFloat(estimate.total || estimate.subtotal || '0'),\n            // Status is an object with { id, name } - extract the name string\n            status: typeof estimate.status === 'object' && estimate.status?.name \n              ? estimate.status.name \n              : (estimate.status || 'Open'),\n            createdOn: estimate.createdOn || estimate.createdDate,\n            expiresOn: expiresDate.toISOString(),\n            expirationStatus,\n            daysUntilExpiration,\n            jobId: estimate.jobId,\n            jobNumber: estimate.job?.jobNumber || null,\n            summary: estimate.name || estimate.summary || `Estimate #${estimate.number || estimate.id}`,\n            items: enhancedItems,\n          };\n        })\n      );\n      \n      return enhancedEstimates;\n    } catch (error) {\n      console.error('[ServiceTitan] Get customer estimates error:', error);\n      // Return empty array on error rather than throwing\n      return [];\n    }\n  }\n\n  /**\n   * Get pricebook service details by ID\n   */\n  async getPricebookService(serviceId: number): Promise<any> {\n    try {\n      const serviceUrl = `https://api.servicetitan.io/pricebook/v2/tenant/${this.config.tenantId}/services/${serviceId}`;\n      const result = await this.request<any>(serviceUrl, {}, true);\n      \n      return {\n        id: result.id,\n        name: result.name || result.displayName,\n        description: result.description,\n        price: parseFloat(result.price || '0'),\n        imageUrl: result.imageUrl || result.image || null,\n        category: result.category || result.categoryName,\n        type: 'service',\n      };\n    } catch (error) {\n      console.error(`[ServiceTitan] Error fetching pricebook service ${serviceId}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Get pricebook material details by ID\n   */\n  async getPricebookMaterial(materialId: number): Promise<any> {\n    try {\n      const materialUrl = `https://api.servicetitan.io/pricebook/v2/tenant/${this.config.tenantId}/materials/${materialId}`;\n      const result = await this.request<any>(materialUrl, {}, true);\n      \n      return {\n        id: result.id,\n        name: result.name || result.displayName,\n        description: result.description,\n        price: parseFloat(result.price || result.cost || '0'),\n        imageUrl: result.imageUrl || result.image || null,\n        category: result.category || result.categoryName,\n        type: 'material',\n      };\n    } catch (error) {\n      console.error(`[ServiceTitan] Error fetching pricebook material ${materialId}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Get pricebook equipment details by ID\n   */\n  async getPricebookEquipment(equipmentId: number): Promise<any> {\n    try {\n      const equipmentUrl = `https://api.servicetitan.io/pricebook/v2/tenant/${this.config.tenantId}/equipment/${equipmentId}`;\n      const result = await this.request<any>(equipmentUrl, {}, true);\n      \n      return {\n        id: result.id,\n        name: result.name || result.displayName,\n        description: result.description,\n        price: parseFloat(result.price || result.cost || '0'),\n        imageUrl: result.imageUrl || result.image || null,\n        category: result.category || result.categoryName,\n        type: 'equipment',\n      };\n    } catch (error) {\n      console.error(`[ServiceTitan] Error fetching pricebook equipment ${equipmentId}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Get pricebook item image URL\n   */\n  async getPricebookItemImage(imagePath: string): Promise<string | null> {\n    try {\n      if (!imagePath) return null;\n      \n      // ServiceTitan pricebook images endpoint\n      const imageUrl = `https://api.servicetitan.io/pricebook/v2/tenant/${this.config.tenantId}/images?path=${encodeURIComponent(imagePath)}`;\n      \n      // Return the full URL - frontend can fetch the image directly with auth headers\n      return imageUrl;\n    } catch (error) {\n      console.error(`[ServiceTitan] Error getting pricebook image ${imagePath}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Sync all customers from ServiceTitan to local database\n   * Paginates through all customers and stores them with normalized contacts\n   */\n  async syncAllCustomers(): Promise<{ customersCount: number; contactsCount: number; duration: number }> {\n    const startTime = Date.now();\n    console.log('[ServiceTitan Sync] Starting full customer sync...');\n    \n    try {\n      const { customersXlsx, contactsXlsx } = await import('@shared/schema');\n      const { eq } = await import('drizzle-orm');\n      \n      let page = 1;\n      let hasMore = true;\n      let totalCustomers = 0;\n      let totalContacts = 0;\n      let customersWithJobs = 0;\n      const pageSize = 200; // Increased from 50 to reduce API calls\n\n      // Use upsert strategy - no deletion, just update existing records\n      console.log('[ServiceTitan Sync] Using upsert strategy for zero-downtime sync...');\n      console.log('[ServiceTitan Sync] Will also fetch job counts for each customer...');\n\n      while (hasMore) {\n        console.log(`[ServiceTitan Sync] Fetching page ${page}...`);\n        \n        // Fetch customers page (use relative endpoint, request() will prepend baseUrl)\n        const result = await this.request<{ data: any[]; hasMore: boolean }>(`/customers?page=${page}&pageSize=${pageSize}`);\n        \n        const customers = result.data || [];\n        hasMore = result.hasMore || false;\n        \n        if (customers.length === 0) {\n          break;\n        }\n\n        // Process each customer\n        let customersWithJobs = 0;\n        let totalJobsProcessed = 0;\n        let highValueCustomers: { id: number; name: string; jobCount: number }[] = [];\n        let skippedInactive = 0;\n        \n        for (let idx = 0; idx < customers.length; idx++) {\n          const customer = customers[idx];\n          \n          // SKIP INACTIVE/DEACTIVATED CUSTOMERS - only sync active customers\n          if (customer.active === false) {\n            skippedInactive++;\n            continue;\n          }\n          \n          // Show progress every 10 customers\n          if ((idx + 1) % 10 === 0) {\n            console.log(`[ServiceTitan Sync] Processing customer ${idx + 1}/${customers.length}...`);\n          }\n          \n          try {\n            // Fetch ALL jobs for this customer to get accurate count\n            let jobCount = 0;\n            try {\n              // Jobs API uses different base path (jpm/v2 instead of crm/v2)\n              const jobsBaseUrl = `https://api.servicetitan.io/jpm/v2/tenant/${this.config.tenantId}`;\n              let page = 1;\n              let hasMore = true;\n              const pageSize = 100; // ServiceTitan max page size\n              \n              while (hasMore) {\n                const response = await fetch(\n                  `${jobsBaseUrl}/jobs?customerId=${customer.id}&jobStatus=Completed&page=${page}&pageSize=${pageSize}`,\n                  {\n                    headers: {\n                      'Authorization': `Bearer ${this.accessToken}`,\n                      'ST-App-Key': this.config.appKey,\n                      'Content-Type': 'application/json',\n                    },\n                  }\n                );\n                \n                if (response.ok) {\n                  const jobsResult = await response.json();\n                  \n                  if (jobsResult.data && jobsResult.data.length > 0) {\n                    jobCount += jobsResult.data.length;\n                  }\n                  \n                  // Continue pagination if there are more pages\n                  hasMore = jobsResult.hasMore || false;\n                  page++;\n                  \n                  // Safety check to prevent infinite loops\n                  if (page > 50) { // Max 5000 jobs per customer (50 pages * 100)\n                    console.log(`[ServiceTitan Sync]  Customer ${customer.id} has over 5000 jobs, stopping pagination`);\n                    break;\n                  }\n                } else {\n                  // Stop on any error\n                  hasMore = false;\n                }\n              }\n              \n              // Track statistics\n              if (jobCount > 0) {\n                customersWithJobs++;\n                totalJobsProcessed += jobCount;\n              }\n              \n              // Log progress for customers with many jobs\n              if (jobCount > 100) {\n                console.log(`[ServiceTitan Sync]  High-value customer: ${customer.name} (ID: ${customer.id}) - ${jobCount} completed jobs`);\n                highValueCustomers.push({ id: customer.id, name: customer.name || 'Unknown', jobCount });\n              }\n              \n            } catch (jobError) {\n              // Silently continue with jobCount = 0 - don't log to avoid flooding logs\n              // Jobs API might not have data for all customers\n            }\n\n            // Insert customer with job count\n            await db.insert(customersXlsx).values({\n              id: customer.id,\n              name: customer.name || 'Unknown',\n              type: customer.type || 'Residential',\n              street: customer.address?.street || null,\n              city: customer.address?.city || null,\n              state: customer.address?.state || null,\n              zip: customer.address?.zip || null,\n              active: customer.active ?? true,\n              balance: customer.balance?.toString() || '0.00',\n              jobCount: jobCount,\n            }).onConflictDoUpdate({\n              target: customersXlsx.id,\n              set: {\n                name: customer.name || 'Unknown',\n                type: customer.type || 'Residential',\n                street: customer.address?.street || null,\n                city: customer.address?.city || null,\n                state: customer.address?.state || null,\n                zip: customer.address?.zip || null,\n                active: customer.active ?? true,\n                balance: customer.balance?.toString() || '0.00',\n                jobCount: jobCount,\n                lastSyncedAt: new Date(),\n              },\n            });\n            \n            totalCustomers++;\n            if (jobCount > 0) {\n              customersWithJobs++;\n            }\n\n            // Clean up old contacts for this customer before syncing new ones\n            // This ensures we don't have stale contacts if they were removed in ServiceTitan\n            await db.delete(contactsXlsx).where(eq(contactsXlsx.customerId, customer.id));\n\n            // Fetch and store customer contacts\n            const contacts = await this.getCustomerContacts(customer.id);\n            \n            for (const contact of contacts) {\n              const contactType = contact.type || 'Unknown';\n              const value = contact.value || contact.phoneNumber || contact.email || '';\n              \n              if (!value) continue;\n\n              // Normalize based on type\n              let normalizedValue = '';\n              if (contactType.toLowerCase().includes('phone') || contactType.toLowerCase().includes('mobile')) {\n                normalizedValue = normalizePhone(value);\n              } else if (contactType.toLowerCase().includes('email')) {\n                normalizedValue = normalizeEmail(value);\n              } else {\n                normalizedValue = value.toLowerCase().trim();\n              }\n\n              if (normalizedValue) {\n                await db.insert(contactsXlsx).values({\n                  customerId: customer.id,\n                  contactType,\n                  value,\n                  normalizedValue,\n                  isPrimary: false, // ServiceTitan doesn't expose primary flag clearly\n                }).onConflictDoNothing();\n                \n                totalContacts++;\n              }\n            }\n          } catch (error) {\n            console.error(`[ServiceTitan Sync] Error processing customer ${customer.id}:`, error);\n            // Continue with next customer\n          }\n        }\n\n        // Log page summary if we found high-value customers or skipped inactive\n        if (highValueCustomers.length > 0 || skippedInactive > 0) {\n          console.log(`[ServiceTitan Sync] Page ${page - 1} Summary:`);\n          console.log(`  - Customers with jobs: ${customersWithJobs}/${customers.length}`);\n          console.log(`  - Total jobs counted: ${totalJobsProcessed}`);\n          console.log(`  - High-value customers (100+ jobs): ${highValueCustomers.length}`);\n          if (skippedInactive > 0) {\n            console.log(`  - Skipped inactive/deactivated: ${skippedInactive}`);\n          }\n          \n          // Show top 3 high-value customers from this page\n          const topCustomers = highValueCustomers.slice(0, 3);\n          topCustomers.forEach(c => {\n            console.log(`     ${c.name}: ${c.jobCount} jobs`);\n          });\n        }\n        \n        page++;\n        \n        // Update heartbeat to prevent stale lock detection\n        const { updateSyncHeartbeat } = await import('./serviceTitanSync');\n        updateSyncHeartbeat();\n        \n        // Log progress every 10 pages\n        if (page % 10 === 0) {\n          console.log(`[ServiceTitan Sync] Progress: ${totalCustomers} customers, ${totalContacts} contacts, ${customersWithJobs} with jobs`);\n        }\n      }\n\n      const duration = Date.now() - startTime;\n      console.log(`[ServiceTitan Sync]  Completed! ${totalCustomers} customers, ${totalContacts} contacts in ${(duration / 1000).toFixed(1)}s`);\n      console.log(`[ServiceTitan Sync]  ${customersWithJobs} customers have completed jobs`);\n      \n      return { customersCount: totalCustomers, contactsCount: totalContacts, duration };\n    } catch (error) {\n      console.error('[ServiceTitan Sync] Failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Search for ALL customer IDs by phone or email in local cache\n   * Returns array of customer IDs (supports multiple accounts per email/phone)\n   */\n  async searchLocalCustomer(phoneOrEmail: string): Promise<number[]> {\n    try {\n      const { contactsXlsx } = await import('@shared/schema');\n      const { eq, or, sql } = await import('drizzle-orm');\n      \n      // Normalize input\n      const normalized = phoneOrEmail.includes('@') \n        ? normalizeEmail(phoneOrEmail)\n        : normalizePhone(phoneOrEmail);\n      \n      if (!normalized) return [];\n\n      // Search in contacts - get ALL matching customer IDs\n      // Handle both exact matches and comma-separated values (e.g., \"email1, email2, email3\")\n      const results = await db\n        .select({ customerId: contactsXlsx.customerId })\n        .from(contactsXlsx)\n        .where(or(\n          eq(contactsXlsx.normalizedValue, normalized),\n          sql`${contactsXlsx.normalizedValue} LIKE ${'%' + normalized + '%'}`\n        ));\n\n      // Return unique customer IDs\n      const uniqueCustomerIds = Array.from(new Set(results.map(r => r.customerId)));\n      return uniqueCustomerIds;\n    } catch (error) {\n      console.error('[ServiceTitan] Local search error:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Search for ALL customers matching phone or email (for multi-account support)\n   * Returns array of customer IDs with full customer details\n   */\n  async searchAllMatchingCustomers(phoneOrEmail: string): Promise<Array<{\n    id: number;\n    name: string;\n    type: string;\n    email?: string;\n    phone?: string;\n    mobilePhone?: string;\n    address?: string;\n  }>> {\n    try {\n      const { contactsXlsx, customersXlsx } = await import('@shared/schema');\n      const { eq, or, sql, inArray } = await import('drizzle-orm');\n      \n      // Normalize input\n      const normalized = phoneOrEmail.includes('@') \n        ? normalizeEmail(phoneOrEmail)\n        : normalizePhone(phoneOrEmail);\n      \n      if (!normalized) return [];\n\n      // Find all matching contact records\n      // Handle both exact matches and comma-separated values\n      const contactResults = await db\n        .select({ customerId: contactsXlsx.customerId })\n        .from(contactsXlsx)\n        .where(or(\n          eq(contactsXlsx.normalizedValue, normalized),\n          sql`${contactsXlsx.normalizedValue} LIKE ${'%' + normalized + '%'}`\n        ));\n\n      if (contactResults.length === 0) {\n        console.log('[ServiceTitan] No matching customers in cache');\n        return [];\n      }\n\n      // Get unique customer IDs\n      const customerIds = Array.from(new Set(contactResults.map(c => c.customerId)));\n      console.log(`[ServiceTitan] Found ${customerIds.length} matching customer(s) in cache`);\n\n      // Fetch full customer details\n      const customers = await db\n        .select()\n        .from(customersXlsx)\n        .where(inArray(customersXlsx.id, customerIds));\n\n      return customers.map(c => ({\n        id: c.id,\n        name: c.name || 'Unknown',\n        type: c.type || 'Residential',\n        email: c.email || undefined,\n        phone: c.phone || undefined,\n        mobilePhone: c.mobilePhone || undefined,\n        address: [c.street, c.city, c.state, c.zip].filter(Boolean).join(', ')\n      }));\n    } catch (error) {\n      console.error('[ServiceTitan] Search all matching customers error:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Search with fallback: Try local cache first, then live API\n   * Caches result on-demand if found via live API\n   * Returns first matching customer ID (for backwards compatibility)\n   */\n  async searchCustomerWithFallback(phoneOrEmail: string): Promise<number | null> {\n    // Try local cache first (instant)\n    const cachedCustomerIds = await this.searchLocalCustomer(phoneOrEmail);\n    if (cachedCustomerIds.length > 0) {\n      console.log(`[ServiceTitan]  Found ${cachedCustomerIds.length} customer(s) in local cache, returning first`);\n      return cachedCustomerIds[0];\n    }\n\n    // Fallback to live API search (slower)\n    console.log('[ServiceTitan]  Not in cache, searching live API...');\n    \n    // Detect if input is email or phone and pass correct parameters\n    const isEmail = phoneOrEmail.includes('@');\n    const email = isEmail ? phoneOrEmail : '';\n    const phone = isEmail ? '' : phoneOrEmail;\n    \n    console.log(`[ServiceTitan] Searching with ${isEmail ? 'email' : 'phone'}: \"${phoneOrEmail}\"`);\n    const liveCustomer = await this.searchCustomer(email, phone);\n    \n    if (liveCustomer) {\n      console.log(`[ServiceTitan]  Found customer ${liveCustomer.id} via live API, caching...`);\n      \n      // Cache on-demand\n      try {\n        const { customersXlsx, contactsXlsx } = await import('@shared/schema');\n        \n        // Store customer WITH email and phone from the customer record\n        await db.insert(customersXlsx).values({\n          id: liveCustomer.id,\n          name: liveCustomer.name || 'Unknown',\n          type: (liveCustomer as any).type || 'Residential',\n          email: liveCustomer.email || null,\n          phone: liveCustomer.phoneNumber || null,\n          street: liveCustomer.address?.street || null,\n          city: liveCustomer.address?.city || null,\n          state: liveCustomer.address?.state || null,\n          zip: liveCustomer.address?.zip || null,\n          active: true,\n          balance: '0.00',\n        }).onConflictDoUpdate({\n          target: customersXlsx.id,\n          set: { \n            email: liveCustomer.email || null,\n            phone: liveCustomer.phoneNumber || null,\n            lastSyncedAt: new Date() \n          },\n        });\n\n        // Store contacts from ServiceTitan contacts API\n        const contacts = await this.getCustomerContacts(liveCustomer.id);\n        for (const contact of contacts) {\n          const contactType = contact.type || 'Unknown';\n          const value = contact.value || contact.phoneNumber || contact.email || '';\n          \n          if (!value) continue;\n\n          let normalizedValue = '';\n          if (contactType.toLowerCase().includes('phone') || contactType.toLowerCase().includes('mobile')) {\n            normalizedValue = normalizePhone(value);\n          } else if (contactType.toLowerCase().includes('email')) {\n            normalizedValue = normalizeEmail(value);\n          } else {\n            normalizedValue = value.toLowerCase().trim();\n          }\n\n          if (normalizedValue) {\n            await db.insert(contactsXlsx).values({\n              customerId: liveCustomer.id,\n              contactType,\n              value,\n              normalizedValue,\n              isPrimary: false,\n            }).onConflictDoNothing();\n          }\n        }\n        \n        // ALSO store email/phone from customer record as contacts for searchability\n        // This handles customers who have email/phone on the customer record but no contacts list\n        if (liveCustomer.email) {\n          const emailNormalized = normalizeEmail(liveCustomer.email);\n          if (emailNormalized) {\n            await db.insert(contactsXlsx).values({\n              customerId: liveCustomer.id,\n              contactType: 'Email',\n              value: liveCustomer.email,\n              normalizedValue: emailNormalized,\n              isPrimary: true,\n            }).onConflictDoNothing();\n          }\n        }\n        \n        if (liveCustomer.phoneNumber) {\n          const phoneNormalized = normalizePhone(liveCustomer.phoneNumber);\n          if (phoneNormalized) {\n            await db.insert(contactsXlsx).values({\n              customerId: liveCustomer.id,\n              contactType: 'Phone',\n              value: liveCustomer.phoneNumber,\n              normalizedValue: phoneNormalized,\n              isPrimary: true,\n            }).onConflictDoNothing();\n          }\n        }\n        \n        console.log(`[ServiceTitan]  Cached customer ${liveCustomer.id} with ${contacts.length} contacts from API + customer record email/phone`);\n      } catch (error) {\n        console.error('[ServiceTitan] Failed to cache customer:', error);\n        // Non-fatal, customer was still found\n      }\n      \n      return liveCustomer.id;\n    }\n\n    console.log('[ServiceTitan]  Customer not found in cache or live API');\n    return null;\n  }\n\n  /**\n   * Search for completed jobs for a customer after a specific date\n   * Used to detect when a referred customer has their first qualifying job\n   */\n  async getCustomerJobs(customerId: number, completedAfter?: Date): Promise<{\n    id: number;\n    jobNumber: string;\n    customerId: number;\n    completedOn: string | null;\n    total: number;\n    status: string;\n  }[]> {\n    try {\n      // ServiceTitan Jobs API uses a different base URL\n      const jobsBaseUrl = `https://api.servicetitan.io/jpm/v2/tenant/${this.config.tenantId}`;\n      \n      let endpoint = `${jobsBaseUrl}/jobs?customerId=${customerId}`;\n      \n      // Add date filter if provided\n      if (completedAfter) {\n        const dateStr = completedAfter.toISOString().split('T')[0]; // YYYY-MM-DD format\n        endpoint += `&completedOnOrAfter=${dateStr}`;\n      }\n\n      console.log('[ServiceTitan] Fetching jobs for customer', customerId, 'after', completedAfter);\n      \n      const response = await this.request<{\n        data: Array<{\n          id: number;\n          jobNumber: string;\n          customerId: number;\n          completedOn?: string;\n          total: number;\n          jobStatus: string;\n        }>;\n      }>(endpoint, {}, true);\n\n      return response.data.map(job => ({\n        id: job.id,\n        jobNumber: job.jobNumber,\n        customerId: job.customerId,\n        completedOn: job.completedOn || null,\n        total: job.total,\n        status: job.jobStatus\n      }));\n    } catch (error) {\n      console.error('[ServiceTitan] Error fetching customer jobs:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create a customer credit adjustment (for referral rewards)\n   * Uses ServiceTitan Accounting API to issue credit to customer account\n   */\n  async createCustomerCredit(customerId: number, amount: number, memo: string): Promise<{\n    id: number;\n    customerId: number;\n    amount: number;\n    memo: string;\n  }> {\n    try {\n      // ServiceTitan Accounting API uses a different base URL\n      const accountingBaseUrl = `https://api.servicetitan.io/accounting/v2/tenant/${this.config.tenantId}`;\n      const endpoint = `${accountingBaseUrl}/customer-adjustments`;\n\n      console.log('[ServiceTitan] Creating customer credit:', {\n        customerId,\n        amount,\n        memo\n      });\n\n      const response = await this.request<{\n        id: number;\n        customerId: number;\n        amount: number;\n        memo: string;\n      }>(endpoint, {\n        method: 'POST',\n        body: JSON.stringify({\n          customerId,\n          amount: amount, // Amount in cents (2500 = $25.00)\n          type: 'Credit',\n          memo,\n          date: new Date().toISOString()\n        })\n      }, true);\n\n      console.log('[ServiceTitan]  Credit created successfully:', response.id);\n      return response;\n    } catch (error) {\n      console.error('[ServiceTitan] Error creating customer credit:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create a pinned note on customer account (for referral credit tracking)\n   * Uses ServiceTitan CRM API to create notes that appear at top of customer file\n   */\n  async createCustomerNote(customerId: number, noteText: string, pinToTop: boolean = true): Promise<{\n    id: number;\n    customerId: number;\n    text: string;\n  }> {\n    try {\n      const endpoint = `/customers/${customerId}/notes`;\n\n      console.log('[ServiceTitan] Creating customer note:', {\n        customerId,\n        noteText: noteText.substring(0, 50) + '...',\n        pinToTop\n      });\n\n      const response = await this.request<{\n        id: number;\n        customerId: number;\n        text: string;\n      }>(endpoint, {\n        method: 'POST',\n        body: JSON.stringify({\n          text: noteText,\n          pinToTop\n        })\n      });\n\n      console.log('[ServiceTitan]  Note created successfully:', response.id);\n      return response;\n    } catch (error) {\n      console.error('[ServiceTitan] Error creating customer note:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all notes for a customer (to check existing credit balance notes)\n   */\n  async getCustomerNotes(customerId: number): Promise<Array<{\n    id: number;\n    text: string;\n    pinToTop: boolean;\n    createdOn: string;\n  }>> {\n    try {\n      const endpoint = `/customers/${customerId}/notes`;\n\n      const response = await this.request<{\n        data: Array<{\n          id: number;\n          text: string;\n          pinToTop: boolean;\n          createdOn: string;\n        }>;\n      }>(endpoint);\n\n      return response.data || [];\n    } catch (error) {\n      console.error('[ServiceTitan] Error fetching customer notes:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Update an existing customer note (for updating credit balance)\n   */\n  async updateCustomerNote(customerId: number, noteId: number, noteText: string, pinToTop: boolean = true): Promise<void> {\n    try {\n      const endpoint = `/customers/${customerId}/notes/${noteId}`;\n\n      console.log('[ServiceTitan] Updating customer note:', {\n        customerId,\n        noteId,\n        noteText: noteText.substring(0, 50) + '...'\n      });\n\n      await this.request(endpoint, {\n        method: 'PUT',\n        body: JSON.stringify({\n          text: noteText,\n          pinToTop\n        })\n      });\n\n      console.log('[ServiceTitan]  Note updated successfully');\n    } catch (error) {\n      console.error('[ServiceTitan] Error updating customer note:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch jobs with incremental sync support using modifiedOnOrAfter watermark\n   * Returns jobs in batches for efficient processing\n   */\n  async fetchJobsIncremental(modifiedOnOrAfter?: Date, batchSize: number = 250): Promise<{\n    jobs: any[];\n    hasMore: boolean;\n    highestModifiedOn: Date | null;\n  }> {\n    try {\n      const jobsBaseUrl = `https://api.servicetitan.io/jpm/v2/tenant/${this.config.tenantId}`;\n      let endpoint = `${jobsBaseUrl}/jobs?pageSize=${batchSize}`;\n      \n      // Add incremental sync filter\n      if (modifiedOnOrAfter) {\n        const dateStr = modifiedOnOrAfter.toISOString();\n        endpoint += `&modifiedOnOrAfter=${dateStr}`;\n        console.log('[ServiceTitan Jobs Sync]  Fetching jobs modified after:', dateStr);\n      } else {\n        console.log('[ServiceTitan Jobs Sync]  Fetching ALL jobs (initial sync)');\n      }\n\n      const response = await this.request<{\n        data: Array<{\n          id: number;\n          jobNumber: string;\n          customerId: number;\n          jobType?: string;\n          businessUnitId?: number;\n          jobStatus: string;\n          completedOn?: string;\n          total: number;\n          invoice?: number;\n          createdOn: string;\n          modifiedOn: string;\n        }>;\n        hasMore: boolean;\n      }>(endpoint, {}, true);\n\n      // Track highest modifiedOn for next watermark\n      let highestModifiedOn: Date | null = null;\n      if (response.data && response.data.length > 0) {\n        const modifiedDates = response.data.map(j => new Date(j.modifiedOn));\n        highestModifiedOn = new Date(Math.max(...modifiedDates.map(d => d.getTime())));\n      }\n\n      console.log('[ServiceTitan Jobs Sync]  Fetched', response.data?.length || 0, 'jobs');\n      \n      return {\n        jobs: response.data || [],\n        hasMore: response.hasMore || false,\n        highestModifiedOn\n      };\n    } catch (error) {\n      console.error('[ServiceTitan Jobs Sync]  Error fetching jobs:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Sync all jobs to database with staging  normalized table pattern\n   * Uses watermarks for incremental sync\n   */\n  async syncAllJobs(): Promise<{\n    jobsCount: number;\n    customersUpdated: number;\n    duration: number;\n  }> {\n    const startTime = Date.now();\n    const { serviceTitanJobsStaging, serviceTitanJobs, customersXlsx, syncWatermarks } = await import('@shared/schema');\n    const { eq, sql } = await import('drizzle-orm');\n\n    try {\n      console.log('[ServiceTitan Jobs Sync]  Starting incremental job sync...');\n\n      // Get last watermark\n      const watermark = await db\n        .select()\n        .from(syncWatermarks)\n        .where(eq(syncWatermarks.syncType, 'jobs'))\n        .limit(1);\n\n      const lastModifiedOn = watermark[0]?.lastModifiedOnFetched || null;\n      let totalJobsFetched = 0;\n      let hasMore = true;\n      let currentWatermark = lastModifiedOn;\n\n      // Fetch jobs in batches\n      while (hasMore) {\n        const { jobs, hasMore: more, highestModifiedOn } = await this.fetchJobsIncremental(\n          currentWatermark || undefined,\n          250\n        );\n\n        if (jobs.length === 0) {\n          break;\n        }\n\n        // Stage raw jobs (idempotent - upsert based on jobId)\n        for (const job of jobs) {\n          await db\n            .insert(serviceTitanJobsStaging)\n            .values({\n              jobId: job.id,\n              rawData: job,\n              fetchedAt: new Date(),\n            })\n            .onConflictDoUpdate({\n              target: serviceTitanJobsStaging.jobId,\n              set: {\n                rawData: job,\n                fetchedAt: new Date(),\n              },\n            });\n        }\n\n        // Normalize staged jobs to serviceTitanJobs table\n        const stagedJobs = await db\n          .select()\n          .from(serviceTitanJobsStaging)\n          .where(eq(serviceTitanJobsStaging.processedAt, null as any));\n\n        for (const staged of stagedJobs) {\n          try {\n            const job = staged.rawData as any;\n            \n            // Upsert to normalized jobs table\n            await db\n              .insert(serviceTitanJobs)\n              .values({\n                id: job.id,\n                jobNumber: job.jobNumber,\n                customerId: job.customerId,\n                jobType: job.jobType || null,\n                businessUnitId: job.businessUnitId || null,\n                jobStatus: job.jobStatus,\n                completedOn: job.completedOn ? new Date(job.completedOn) : null,\n                total: Math.round((job.total || 0) * 100), // Convert to cents\n                invoice: Math.round((job.invoice || 0) * 100),\n                createdOn: new Date(job.createdOn),\n                modifiedOn: new Date(job.modifiedOn),\n                lastSyncedAt: new Date(),\n              })\n              .onConflictDoUpdate({\n                target: serviceTitanJobs.id,\n                set: {\n                  jobNumber: job.jobNumber,\n                  jobType: job.jobType || null,\n                  jobStatus: job.jobStatus,\n                  completedOn: job.completedOn ? new Date(job.completedOn) : null,\n                  total: Math.round((job.total || 0) * 100),\n                  invoice: Math.round((job.invoice || 0) * 100),\n                  modifiedOn: new Date(job.modifiedOn),\n                  lastSyncedAt: new Date(),\n                },\n              });\n\n            // Mark as processed\n            await db\n              .update(serviceTitanJobsStaging)\n              .set({ processedAt: new Date() })\n              .where(eq(serviceTitanJobsStaging.id, staged.id));\n\n          } catch (error) {\n            console.error('[ServiceTitan Jobs Sync]  Error processing job:', error);\n            // Mark error but continue\n            await db\n              .update(serviceTitanJobsStaging)\n              .set({ processingError: (error as Error).message })\n              .where(eq(serviceTitanJobsStaging.id, staged.id));\n          }\n        }\n\n        totalJobsFetched += jobs.length;\n        \n        // Update watermark for next batch\n        if (highestModifiedOn) {\n          currentWatermark = highestModifiedOn;\n        }\n\n        hasMore = more;\n      }\n\n      // Update customer job counts (aggregate from completed jobs)\n      console.log('[ServiceTitan Jobs Sync]  Updating customer job counts...');\n      await db.execute(sql`\n        UPDATE customers_xlsx c\n        SET job_count = (\n          SELECT COUNT(*)\n          FROM service_titan_jobs j\n          WHERE j.customer_id = c.id\n            AND j.job_status = 'Completed'\n            AND j.completed_on IS NOT NULL\n        )\n      `);\n\n      const customersUpdatedResult = await db.execute(sql`\n        SELECT COUNT(*) as count \n        FROM customers_xlsx \n        WHERE job_count > 0\n      `);\n      const customersUpdated = customersUpdatedResult.rows[0]?.count || 0;\n\n      // Update watermark\n      await db\n        .update(syncWatermarks)\n        .set({\n          lastSuccessfulSyncAt: new Date(),\n          lastModifiedOnFetched: currentWatermark,\n          recordsProcessed: totalJobsFetched,\n          syncDuration: Date.now() - startTime,\n          updatedAt: new Date(),\n        })\n        .where(eq(syncWatermarks.syncType, 'jobs'));\n\n      const duration = Date.now() - startTime;\n      console.log('[ServiceTitan Jobs Sync]  Sync complete!');\n      console.log(`  - Jobs synced: ${totalJobsFetched}`);\n      console.log(`  - Customers with jobs: ${customersUpdated}`);\n      console.log(`  - Duration: ${(duration / 1000).toFixed(1)}s`);\n\n      return {\n        jobsCount: totalJobsFetched,\n        customersUpdated: Number(customersUpdated),\n        duration,\n      };\n    } catch (error) {\n      const { eq } = await import('drizzle-orm');\n      \n      // Log error to watermark\n      await db\n        .update(syncWatermarks)\n        .set({\n          lastError: (error as Error).message,\n          lastErrorAt: new Date(),\n          updatedAt: new Date(),\n        })\n        .where(eq(syncWatermarks.syncType, 'jobs'));\n\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch job forms for a specific job\n   * Uses Forms API: GET /forms/v2/tenant/{tenantId}/jobs/{jobId}/forms\n   */\n  async getJobForms(jobId: number): Promise<any[]> {\n    try {\n      const formsUrl = `https://api.servicetitan.io/forms/v2/tenant/${this.config.tenantId}/jobs/${jobId}/forms`;\n      \n      const response = await this.request<{ data: any[] }>(\n        formsUrl,\n        {},\n        true // Use full URL\n      );\n\n      return response.data || [];\n    } catch (error) {\n      console.error(`[ServiceTitan Forms] Error fetching forms for job ${jobId}:`, error);\n      return [];\n    }\n  }\n\n  /**\n   * Sync job forms for recently modified jobs\n   * Extracts technician notes, customer concerns, and recommendations\n   */\n  async syncJobForms(options: {\n    sinceDate?: Date;\n    jobIds?: number[];\n    batchSize?: number;\n  } = {}): Promise<{\n    formsCount: number;\n    jobsProcessed: number;\n    duration: number;\n  }> {\n    const startTime = Date.now();\n    const { serviceTitanJobForms, serviceTitanJobs } = await import('@shared/schema');\n    const { eq, sql, inArray } = await import('drizzle-orm');\n    \n    try {\n      console.log('[ServiceTitan Forms Sync]  Starting forms sync...');\n      \n      let jobsToSync: any[] = [];\n      \n      // Strategy 1: Sync specific job IDs (if provided)\n      if (options.jobIds && options.jobIds.length > 0) {\n        console.log(`[ServiceTitan Forms Sync] Syncing ${options.jobIds.length} specific jobs`);\n        jobsToSync = await db\n          .select()\n          .from(serviceTitanJobs)\n          .where(inArray(serviceTitanJobs.id, options.jobIds))\n          .limit(options.batchSize || 100);\n      }\n      // Strategy 2: Sync recently modified jobs (default: last 30 days)\n      else {\n        const sinceDate = options.sinceDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n        console.log(`[ServiceTitan Forms Sync] Syncing jobs modified since ${sinceDate.toISOString()}`);\n        \n        jobsToSync = await db\n          .select()\n          .from(serviceTitanJobs)\n          .where(sql`${serviceTitanJobs.modifiedOn} >= ${sinceDate}`)\n          .orderBy(sql`${serviceTitanJobs.modifiedOn} DESC`)\n          .limit(options.batchSize || 100);\n      }\n\n      console.log(`[ServiceTitan Forms Sync]  Processing ${jobsToSync.length} jobs...`);\n      \n      let totalFormsSynced = 0;\n      let jobsProcessed = 0;\n\n      // Process jobs in batches of 10 to avoid rate limiting\n      const BATCH_SIZE = 10;\n      for (let i = 0; i < jobsToSync.length; i += BATCH_SIZE) {\n        const batch = jobsToSync.slice(i, i + BATCH_SIZE);\n        \n        await Promise.all(batch.map(async (job) => {\n          try {\n            const forms = await this.getJobForms(job.id);\n            \n            if (forms.length === 0) {\n              return;\n            }\n\n            // Process each form\n            for (const form of forms) {\n              try {\n                // Parse form data to extract key fields\n                const parsedFields = this.parseFormFields(form);\n                const technicianNotes = this.extractTechnicianNotes(parsedFields);\n                const customerConcerns = this.extractCustomerConcerns(parsedFields);\n                const recommendationsMade = this.extractRecommendations(parsedFields);\n                const equipmentCondition = this.extractEquipmentCondition(parsedFields);\n\n                // Upsert to database\n                await db\n                  .insert(serviceTitanJobForms)\n                  .values({\n                    formId: form.id,\n                    jobId: job.id,\n                    customerId: job.customerId,\n                    formTemplateId: form.formTemplate?.id || null,\n                    formTemplateName: form.formTemplate?.name || null,\n                    rawFormData: form,\n                    parsedFields,\n                    technicianNotes,\n                    customerConcerns,\n                    recommendationsMade,\n                    equipmentCondition,\n                    submittedOn: form.submittedOn ? new Date(form.submittedOn) : new Date(),\n                    submittedBy: form.submittedBy?.name || null,\n                    lastSyncedAt: new Date(),\n                  })\n                  .onConflictDoUpdate({\n                    target: serviceTitanJobForms.formId,\n                    set: {\n                      rawFormData: form,\n                      parsedFields,\n                      technicianNotes,\n                      customerConcerns,\n                      recommendationsMade,\n                      equipmentCondition,\n                      lastSyncedAt: new Date(),\n                    },\n                  });\n\n                totalFormsSynced++;\n              } catch (error) {\n                console.error(`[ServiceTitan Forms Sync] Error processing form ${form.id}:`, error);\n              }\n            }\n\n            jobsProcessed++;\n            \n            if (jobsProcessed % 20 === 0) {\n              console.log(`[ServiceTitan Forms Sync] Progress: ${jobsProcessed}/${jobsToSync.length} jobs processed`);\n            }\n          } catch (error) {\n            console.error(`[ServiceTitan Forms Sync] Error syncing forms for job ${job.id}:`, error);\n          }\n        }));\n      }\n\n      const duration = Date.now() - startTime;\n      console.log('[ServiceTitan Forms Sync]  Sync complete!');\n      console.log(`  - Jobs processed: ${jobsProcessed}`);\n      console.log(`  - Forms synced: ${totalFormsSynced}`);\n      console.log(`  - Duration: ${(duration / 1000).toFixed(1)}s`);\n\n      return {\n        formsCount: totalFormsSynced,\n        jobsProcessed,\n        duration,\n      };\n    } catch (error) {\n      console.error('[ServiceTitan Forms Sync]  Sync failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Parse form fields into key-value pairs\n   */\n  private parseFormFields(form: any): Record<string, any> {\n    const parsed: Record<string, any> = {};\n    \n    if (!form.fields || !Array.isArray(form.fields)) {\n      return parsed;\n    }\n\n    for (const field of form.fields) {\n      const key = field.name || field.label || `field_${field.id}`;\n      parsed[key] = field.value || field.text || field.selectedOption || null;\n    }\n\n    return parsed;\n  }\n\n  /**\n   * Extract technician notes from form fields\n   */\n  private extractTechnicianNotes(fields: Record<string, any>): string | null {\n    // Common field names for technician notes\n    const noteFields = [\n      'technician_notes',\n      'notes',\n      'tech_notes',\n      'comments',\n      'observations',\n      'findings',\n      'service_notes',\n      'job_notes',\n    ];\n\n    const notes: string[] = [];\n    \n    for (const [key, value] of Object.entries(fields)) {\n      const lowerKey = key.toLowerCase().replace(/[^a-z]/g, '');\n      \n      if (noteFields.some(f => lowerKey.includes(f.replace(/_/g, ''))) && value) {\n        notes.push(String(value));\n      }\n    }\n\n    return notes.length > 0 ? notes.join('\\n\\n') : null;\n  }\n\n  /**\n   * Extract customer concerns from form fields\n   */\n  private extractCustomerConcerns(fields: Record<string, any>): string[] {\n    const concerns: string[] = [];\n    const concernKeywords = [\n      'concern',\n      'issue',\n      'problem',\n      'complaint',\n      'worry',\n    ];\n\n    for (const [key, value] of Object.entries(fields)) {\n      const lowerKey = key.toLowerCase();\n      \n      if (concernKeywords.some(k => lowerKey.includes(k)) && value) {\n        concerns.push(String(value));\n      }\n    }\n\n    return concerns;\n  }\n\n  /**\n   * Extract recommendations from form fields\n   */\n  private extractRecommendations(fields: Record<string, any>): string[] {\n    const recommendations: string[] = [];\n    const recommendationKeywords = [\n      'recommend',\n      'suggestion',\n      'should replace',\n      'needs replacement',\n      'should consider',\n      'advise',\n    ];\n\n    for (const [key, value] of Object.entries(fields)) {\n      const lowerKey = key.toLowerCase();\n      const lowerValue = String(value || '').toLowerCase();\n      \n      if (recommendationKeywords.some(k => lowerKey.includes(k) || lowerValue.includes(k)) && value) {\n        recommendations.push(String(value));\n      }\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Extract equipment condition assessment\n   */\n  private extractEquipmentCondition(fields: Record<string, any>): string | null {\n    const conditionKeywords = [\n      'condition',\n      'status',\n      'quality',\n      'state',\n    ];\n\n    for (const [key, value] of Object.entries(fields)) {\n      const lowerKey = key.toLowerCase();\n      \n      if (conditionKeywords.some(k => lowerKey.includes(k)) && value) {\n        const lowerValue = String(value).toLowerCase();\n        \n        // Match common condition values\n        if (lowerValue.includes('critical') || lowerValue.includes('failure')) return 'Critical';\n        if (lowerValue.includes('poor') || lowerValue.includes('bad')) return 'Poor';\n        if (lowerValue.includes('fair') || lowerValue.includes('okay')) return 'Fair';\n        if (lowerValue.includes('good')) return 'Good';\n        if (lowerValue.includes('excellent') || lowerValue.includes('great')) return 'Excellent';\n        \n        return String(value);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Marketing API Methods\n   * NOTE: These methods use inferred API schemas based on ServiceTitan documentation patterns.\n   * Adjust request/response structures as needed once exact schemas are confirmed.\n   */\n\n  /**\n   * Get all marketing campaigns\n   */\n  async getCampaigns(): Promise<any[]> {\n    try {\n      const marketingUrl = `https://api.servicetitan.io/marketing/v2/tenant/${this.config.tenantId}/campaigns`;\n      \n      const response = await this.request<any>(marketingUrl, {}, true);\n      \n      // ServiceTitan typically returns { data: [...] }\n      return response.data || response || [];\n    } catch (error) {\n      console.error('[ServiceTitan] Get campaigns error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get a specific marketing campaign by ID\n   */\n  async getCampaign(campaignId: number): Promise<any> {\n    try {\n      const marketingUrl = `https://api.servicetitan.io/marketing/v2/tenant/${this.config.tenantId}/campaigns/${campaignId}`;\n      \n      return await this.request<any>(marketingUrl, {}, true);\n    } catch (error) {\n      console.error('[ServiceTitan] Get campaign error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create a new marketing campaign in ServiceTitan\n   * @param campaignData - Campaign creation data\n   * @returns The created campaign with ServiceTitan ID\n   */\n  async createCampaign(campaignData: {\n    name: string;\n    categoryId?: number;\n    active?: boolean;\n    businessUnitId?: number;\n    phoneNumber?: string;\n  }): Promise<{ id: number; name: string }> {\n    try {\n      const marketingUrl = `https://api.servicetitan.io/marketing/v2/tenant/${this.config.tenantId}/campaigns`;\n      \n      // Build request body based on ServiceTitan patterns\n      const requestBody = {\n        name: campaignData.name,\n        active: campaignData.active ?? true,\n        ...(campaignData.categoryId && { categoryId: campaignData.categoryId }),\n        ...(campaignData.businessUnitId && { businessUnitId: campaignData.businessUnitId }),\n        ...(campaignData.phoneNumber && { phoneNumber: campaignData.phoneNumber }),\n      };\n\n      console.log('[ServiceTitan] Creating campaign:', requestBody);\n\n      const response = await this.request<any>(marketingUrl, {\n        method: 'POST',\n        body: JSON.stringify(requestBody),\n      }, true);\n\n      console.log('[ServiceTitan] Campaign created:', response);\n\n      return {\n        id: response.id || response.data?.id,\n        name: response.name || response.data?.name || campaignData.name,\n      };\n    } catch (error) {\n      console.error('[ServiceTitan] Create campaign error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get campaign categories for organizing campaigns\n   */\n  async getCampaignCategories(): Promise<any[]> {\n    try {\n      const marketingUrl = `https://api.servicetitan.io/marketing/v2/tenant/${this.config.tenantId}/campaign-categories`;\n      \n      const response = await this.request<any>(marketingUrl, {}, true);\n      \n      return response.data || response || [];\n    } catch (error) {\n      console.error('[ServiceTitan] Get campaign categories error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update campaign costs for ROI tracking\n   */\n  async updateCampaignCost(campaignId: number, cost: {\n    month: string; // Format: \"YYYY-MM\"\n    amount: number;\n  }): Promise<void> {\n    try {\n      const marketingUrl = `https://api.servicetitan.io/marketing/v2/tenant/${this.config.tenantId}/campaigns/${campaignId}/costs`;\n      \n      await this.request<any>(marketingUrl, {\n        method: 'POST',\n        body: JSON.stringify(cost),\n      }, true);\n\n      console.log('[ServiceTitan] Campaign cost updated');\n    } catch (error) {\n      console.error('[ServiceTitan] Update campaign cost error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all customers in bulk (for creating lookup maps)\n   * Returns customer ID -> customer name mapping\n   */\n  async getAllCustomersMap(): Promise<Map<number, string>> {\n    try {\n      console.log('[ServiceTitan] Fetching all customers for lookup map...');\n      \n      const customerMap = new Map<number, string>();\n      const PAGE_SIZE = 500;\n      let page = 1;\n      let hasMore = true;\n\n      while (hasMore && page < 100) { // Max 50,000 customers\n        const customersUrl = `https://api.servicetitan.io/crm/v2/tenant/${this.config.tenantId}/customers?page=${page}&pageSize=${PAGE_SIZE}`;\n        const result = await this.request<{ data: any[]; hasMore: boolean }>(customersUrl, {}, true);\n        \n        const customers = result.data || [];\n        console.log(`[ServiceTitan] Page ${page}: Fetched ${customers.length} customers`);\n        \n        // Add to map\n        customers.forEach((customer: any) => {\n          const name = customer.name || customer.companyName || `Customer #${customer.id}`;\n          customerMap.set(customer.id, name);\n        });\n        \n        hasMore = result.hasMore || false;\n        page++;\n        \n        // Stop if we got less than a full page\n        if (customers.length < PAGE_SIZE) {\n          break;\n        }\n      }\n\n      console.log(`[ServiceTitan] Created customer lookup map with ${customerMap.size} customers`);\n      return customerMap;\n    } catch (error) {\n      console.error('[ServiceTitan] Error fetching customer map:', error);\n      // Return empty map on error rather than failing\n      return new Map();\n    }\n  }\n\n  /**\n   * Get all customer memberships from ServiceTitan\n   * Returns all recurring service events (memberships) for all customers\n   */\n  async getAllMemberships(): Promise<any[]> {\n    try {\n      console.log('[ServiceTitan Memberships] Fetching all customer memberships...');\n      \n      // First, fetch all customers to create a lookup map\n      const customerMap = await this.getAllCustomersMap();\n      \n      const membershipsUrl = `https://api.servicetitan.io/memberships/v2/tenant/${this.config.tenantId}/recurring-service-events?pageSize=500`;\n      const result = await this.request<{ data: any[]; hasMore: boolean }>(membershipsUrl, {}, true);\n      \n      let allMemberships = result.data || [];\n      let page = 1;\n      let hasMore = result.hasMore || false;\n\n      while (hasMore && page < 10) {\n        page++;\n        const nextPageUrl = `${membershipsUrl}&page=${page}`;\n        const nextResult = await this.request<{ data: any[]; hasMore: boolean }>(nextPageUrl, {}, true);\n        allMemberships = [...allMemberships, ...(nextResult.data || [])];\n        hasMore = nextResult.hasMore || false;\n      }\n\n      console.log(`[ServiceTitan Memberships] Fetched ${allMemberships.length} total memberships`);\n      \n      return allMemberships.map((m: any) => ({\n        id: m.id,\n        customerId: m.customerId,\n        customerName: customerMap.get(m.customerId) || m.customerName || 'Unknown Customer',\n        membershipId: m.membershipId,\n        membershipName: m.membershipName || m.locationRecurringServiceName || 'VIP Membership',\n        status: m.status || 'Unknown',\n        startDate: m.from || m.createdOn,\n        expirationDate: m.to || m.expirationDate,\n        renewalDate: m.date || m.nextScheduledDate,\n        balance: parseFloat(m.balance || '0'),\n        totalValue: parseFloat(m.total || '0'),\n        description: m.memo || m.description || '',\n        createdOn: m.createdOn,\n        modifiedOn: m.modifiedOn,\n        rawData: m,\n      }));\n    } catch (error) {\n      console.error('[ServiceTitan Memberships] Error fetching all memberships:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update a customer membership status (expire/cancel/suspend)\n   * Uses PATCH endpoint to edit customer membership\n   */\n  async updateMembershipStatus(membershipId: number, updates: {\n    status?: string;\n    expirationDate?: string;\n    cancellationDate?: string;\n  }): Promise<any> {\n    try {\n      console.log(`[ServiceTitan Memberships] Updating membership ${membershipId}:`, updates);\n      \n      const membershipsUrl = `https://api.servicetitan.io/memberships/v2/tenant/${this.config.tenantId}/customer-memberships/${membershipId}`;\n      \n      const requestBody: any = {};\n      \n      if (updates.status) {\n        requestBody.status = updates.status;\n      }\n      \n      if (updates.expirationDate) {\n        requestBody.to = updates.expirationDate;\n      }\n      \n      if (updates.cancellationDate) {\n        requestBody.cancellationDate = updates.cancellationDate;\n      }\n\n      const response = await this.request<any>(membershipsUrl, {\n        method: 'PATCH',\n        body: JSON.stringify(requestBody),\n      }, true);\n\n      console.log(`[ServiceTitan Memberships] Membership ${membershipId} updated successfully`);\n      \n      return response;\n    } catch (error) {\n      console.error(`[ServiceTitan Memberships] Error updating membership ${membershipId}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Bulk update multiple memberships (for expiring old memberships)\n   */\n  async bulkUpdateMemberships(updates: Array<{\n    membershipId: number;\n    status?: string;\n    expirationDate?: string;\n    cancellationDate?: string;\n  }>): Promise<{ success: number; failed: number; errors: any[] }> {\n    console.log(`[ServiceTitan Memberships] Bulk updating ${updates.length} memberships...`);\n    \n    let success = 0;\n    let failed = 0;\n    const errors: any[] = [];\n\n    for (const update of updates) {\n      try {\n        await this.updateMembershipStatus(update.membershipId, {\n          status: update.status,\n          expirationDate: update.expirationDate,\n          cancellationDate: update.cancellationDate,\n        });\n        success++;\n      } catch (error) {\n        failed++;\n        errors.push({\n          membershipId: update.membershipId,\n          error: error instanceof Error ? error.message : 'Unknown error',\n        });\n      }\n    }\n\n    console.log(`[ServiceTitan Memberships] Bulk update complete: ${success} succeeded, ${failed} failed`);\n    \n    return { success, failed, errors };\n  }\n}\n\n// Singleton instance\nlet serviceTitanAPI: ServiceTitanAPI | null = null;\n\nexport function getServiceTitanAPI(): ServiceTitanAPI {\n  if (!serviceTitanAPI) {\n    const clientId = process.env.SERVICETITAN_CLIENT_ID;\n    const clientSecret = process.env.SERVICETITAN_CLIENT_SECRET;\n    const tenantId = process.env.SERVICETITAN_TENANT_ID;\n    const appKey = process.env.SERVICETITAN_APP_KEY;\n\n    if (!clientId || !clientSecret || !tenantId || !appKey) {\n      throw new Error('ServiceTitan credentials not configured');\n    }\n\n    serviceTitanAPI = new ServiceTitanAPI({\n      clientId,\n      clientSecret,\n      tenantId,\n      appKey,\n    });\n  }\n\n  return serviceTitanAPI;\n}\n\n/**\n * Normalize phone number to digits only (strip formatting, country code, extensions)\n * (512) 555-1234  5125551234\n * +1-512-555-1234  5125551234\n * 512-555-1234 x123  5125551234\n * 512-555-1234 ext 123  5125551234\n */\nexport function normalizePhone(phone: string): string {\n  if (!phone) return '';\n  \n  // Remove common extension markers before processing\n  // Match: x123, ext 123, ext. 123, extension 123, #123\n  const withoutExtension = phone.replace(/\\s*(x|ext\\.?|extension|#)\\s*\\d+/gi, '');\n  \n  // Remove all non-digits\n  const digitsOnly = withoutExtension.replace(/\\D/g, '');\n  \n  // Remove leading 1 (US country code) if present and 11 digits\n  if (digitsOnly.length === 11 && digitsOnly.startsWith('1')) {\n    return digitsOnly.substring(1);\n  }\n  \n  return digitsOnly;\n}\n\n/**\n * Normalize email to lowercase for consistent searching\n */\nexport function normalizeEmail(email: string): string {\n  if (!email) return '';\n  return email.trim().toLowerCase();\n}\n\n// Export the class for direct use\nexport { ServiceTitanAPI };\n"],"names":[],"mappings":"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"}